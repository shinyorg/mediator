using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using Microsoft.OpenApi;

namespace Shiny.Mediator.SourceGenerators;


public class OpenApiModelGenerator(MediatorHttpItemConfig config, SourceProductionContext context, Compilation compilation)
{
    readonly string accessor = config.UseInternalClasses ? "internal" : "public";
    readonly HashSet<string> generatedTypes = new();

    public MediatorHttpItemConfig Config => config;
    public SourceProductionContext Context => context;
    public Compilation Compilation { get; private set; } = compilation;

    public void UpdateCompilation(Compilation newCompilation) => Compilation = newCompilation;


    public void GenerateModel(string name, IOpenApiSchema schema)
    {
        var className = name.Pascalize();

        if (this.generatedTypes.Add(className))
        {
            if (schema.Enum?.Count > 0)
            {
                GenerateEnum(className, schema);
            }
            else if (schema.Type?.HasFlag(JsonSchemaType.Object) == true || schema.Properties?.Count > 0)
            {
                GenerateClass(className, schema);
            }
        }
    }

    
    void GenerateEnum(string enumName, IOpenApiSchema schema)
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated>");
        sb.AppendLine("// Code generated by Shiny Mediator OpenAPI Source Generator.");
        sb.AppendLine("// </auto-generated>");
        sb.AppendLine("#nullable disable");
        sb.AppendLine();
        sb.AppendLine($"namespace {config.Namespace};");
        sb.AppendLine();

        // Check if the first enum value is a string-based value
        var firstValue = schema.Enum?.FirstOrDefault();
        var isStringEnum = firstValue != null && firstValue.GetValueKind() == System.Text.Json.JsonValueKind.String;

        if (isStringEnum)
        {
            sb.AppendLine($"[global::System.Text.Json.Serialization.JsonConverter(typeof(global::System.Text.Json.Serialization.JsonStringEnumConverter<global::{config.Namespace}.{enumName}>))]");
        }

        sb.AppendLine(Constants.GeneratedCodeAttributeString);
        sb.AppendLine($"{accessor} enum {enumName}");
        sb.AppendLine("{");

        if (isStringEnum)
        {
            foreach (var ev in schema.Enum!)
            {
                if (ev != null)
                {
                    var strValue = ev.GetValue<string>();
                    sb.AppendLine($"    {strValue},");
                }
            }
        }
        else
        {
            foreach (var ev in schema.Enum!)
            {
                if (ev != null)
                {
                    var intValue = ev.GetValue<int>();
                    sb.AppendLine($"    Value{intValue} = {intValue},");
                }
            }
        }

        sb.AppendLine("}");

        context.AddSource(GetFileName(enumName), SourceText.From(sb.ToString(), Encoding.UTF8));
    }
    

    void GenerateClass(string className, IOpenApiSchema schema)
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated>");
        sb.AppendLine("// Code generated by Shiny Mediator OpenAPI Source Generator.");
        sb.AppendLine("// </auto-generated>");
        sb.AppendLine("#nullable disable");
        sb.AppendLine();
        sb.AppendLine($"namespace {config.Namespace};");
        sb.AppendLine();
        sb.AppendLine(Constants.GeneratedCodeAttributeString);
        sb.Append($"{accessor} partial class {className}");

        // Handle inheritance
        if (schema.AllOf?.Count == 1)
        {
            var baseType = GetSchemaType(schema.AllOf[0]);
            if (baseType != null)
            {
                sb.AppendLine($" : {baseType}");
            }
            else
            {
                sb.AppendLine();
            }
        }
        else
        {
            sb.AppendLine();
        }

        sb.AppendLine("{");

        // Generate properties
        if (schema.Properties != null)
        {
            foreach (var property in schema.Properties)
            {
                var propertyName = property.Key.Pascalize();

                if (property.Value != null)
                {
                    var propSchema = property.Value;
                    string? typeName;

                    // Check if this is a reference to a component schema first
                    if (propSchema is OpenApiSchemaReference)
                    {
                        // Use the referenced type name directly
                        typeName = GetSchemaType(propSchema);
                    }
                    // Check if this is a nested object (no title means it's inline)
                    else if (propSchema.Type?.HasFlag(JsonSchemaType.Object) == true && propSchema.Properties != null && String.IsNullOrEmpty(propSchema.Title))
                    {
                        // Generate nested type (only if not already generated)
                        typeName = className + propertyName;
                        if (generatedTypes.Add(typeName))
                        {
                            GenerateClass(typeName, propSchema);
                        }
                    }
                    else if (propSchema.Enum?.Count > 0 && String.IsNullOrEmpty(propSchema.Title))
                    {
                        // Generate nested enum (only if not already generated)
                        typeName = className + propertyName;
                        if (generatedTypes.Add(typeName))
                        {
                            GenerateEnum(typeName, propSchema);
                        }
                    }
                    else
                    {
                        typeName = GetSchemaType(propSchema);
                    }

                    if (typeName != null)
                    {
                        var isRequired = schema.Required?.Contains(property.Key) ?? false;
                        var typeIncludesNull = propSchema.Type?.HasFlag(JsonSchemaType.Null) ?? false;
                        var isValueType = IsValueType(typeName);
                        
                        // Value types are only nullable if schema explicitly includes null
                        // Reference types are nullable if not required OR schema includes null
                        var isNullable = isValueType 
                            ? typeIncludesNull 
                            : (!isRequired || typeIncludesNull);
                        var nullableSuffix = isNullable ? "?" : String.Empty;
                        
                        sb.AppendLine($"    [global::System.Text.Json.Serialization.JsonPropertyName(\"{property.Key}\")]");
                        sb.AppendLine($"    public {typeName}{nullableSuffix} {propertyName} {{ get; set; }}");
                        sb.AppendLine();
                    }
                }
            }
        }

        sb.AppendLine("}");

        context.AddSource(GetFileName(className), SourceText.From(sb.ToString(), Encoding.UTF8));

        // Generate JSON converter if requested
        if (config.GenerateJsonConverters)
        {
            try
            {
                // Parse the generated source code and add it to compilation so we can get the type symbol
                var parseOptions = Compilation.SyntaxTrees.FirstOrDefault()?.Options as Microsoft.CodeAnalysis.CSharp.CSharpParseOptions ?? Microsoft.CodeAnalysis.CSharp.CSharpParseOptions.Default;
                var syntaxTree = Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree.ParseText(
                    sb.ToString(), 
                    parseOptions,
                    cancellationToken: context.CancellationToken
                );
                UpdateCompilation(Compilation.AddSyntaxTrees(syntaxTree));
                
                var fullyQualifiedTypeName = $"{config.Namespace}.{className}";
                var typeSymbol = Compilation.GetTypeByMetadataName(fullyQualifiedTypeName);
                
                if (typeSymbol != null)
                {
                    JsonConverterSourceGenerator.GenerateJsonConverter(context, typeSymbol);
                }
            }
            catch
            {
                // TODO: I need to log this out properly
                // If we can't generate the JSON converter, just skip it silently
                // This might happen for complex types or if there are other issues
            }
        }
    }

    
    string? GetSchemaType(IOpenApiSchema schema)
    {
        string? type = null;
        if (schema is OpenApiSchemaReference schemaRef && !String.IsNullOrWhiteSpace(schemaRef.Reference.Id))
        {
            var typeName = schemaRef.Reference.Id!.Split('/').Last().Pascalize();
            // Optionally resolve and generate the referenced schema if needed
            // var resolvedSchema = schemaRef.ResolveReference(/* document context */);
            // if (resolvedSchema != null)
            //     GenerateModel(typeName, resolvedSchema);
            
            type = $"global::{config.Namespace}.{typeName}";
        }
        else if (schema.Type != null)
        {
            if (schema.Type.Value.HasFlag(JsonSchemaType.String))
            {
                type = GetStringType(schema);
            }
            else if (schema.Type.Value.HasFlag(JsonSchemaType.Integer))
            {
                type = GetNumberType(schema.Format);
            }
            else if (schema.Type.Value.HasFlag(JsonSchemaType.Number))
            {
                type = GetNumberType(schema.Format);
            }
            else if (schema.Type.Value.HasFlag(JsonSchemaType.Boolean))
            {
                type = "bool";
            }
            else if (schema.Type.Value.HasFlag(JsonSchemaType.Array) && schema.Items != null)
            {
                var listType = GetSchemaType(schema.Items);
                if (listType != null)
                    type = $"global::System.Collections.Generic.List<{listType}>";
            }
            else if (schema.Type.Value.HasFlag(JsonSchemaType.Object))
            {
                if (schema.AdditionalProperties == null)
                {
                    // Object with no additional properties and no title - might be inline definition
                    type = "object";
                }
                else
                {
                    var dictionaryValueType = GetSchemaType(schema.AdditionalProperties);
                    if (dictionaryValueType != null)
                        type = $"global::System.Collections.Generic.Dictionary<string, {dictionaryValueType}>";
                }
            }
            else
            {
                type = "object";
            }
        }
        else if (schema.AllOf?.Count == 1)
        {
            type = GetSchemaType(schema.AllOf[0]);
        }

        return type;
    }

    static string GetStringType(IOpenApiSchema schema)
    {
        // Handle TimeSpan patterns (with or without optional negative sign)
        if (schema.Pattern?.Equals("^-(\\d+\\.)?\\d{2}:\\d{2}:\\d{2}(\\.\\d{1,7})?$") ?? false)
            return "global::System.TimeSpan";
        
        if (schema.Pattern?.Equals("^-?(\\d+\\.)?\\d{2}:\\d{2}:\\d{2}(\\.\\d{1,7})?$") ?? false)
            return "global::System.TimeSpan";

        return schema.Format switch
        {
            "date-time" => "global::System.DateTimeOffset",
            "uuid" => "global::System.Guid",
            "date" => "global::System.DateOnly",
            "time" => "global::System.TimeOnly",
            "date-span" => "global::System.TimeSpan",
            _ => "string"
        };
    }

    static string GetNumberType(string? format) => format switch
    {
        "int32" => "int",
        "int64" => "long",
        "float" => "float",
        _ => "double"
    };

    string GetFileName(string typeName)
    {
        // Sanitize namespace to be file-system safe
        var sanitizedNamespace = config.Namespace.Replace("<", "_").Replace(">", "_");
        return $"{sanitizedNamespace}.{typeName}.g.cs";
    }

    static bool IsValueType(string typeName)
        => typeName is "bool" or "int" or "long" or "float" or "double" or "decimal"
            || typeName.StartsWith("global::System.Guid")
            || typeName.StartsWith("global::System.DateTime")
            || typeName.StartsWith("global::System.DateTimeOffset")
            || typeName.StartsWith("global::System.DateOnly")
            || typeName.StartsWith("global::System.TimeOnly")
            || typeName.StartsWith("global::System.TimeSpan");
}

