using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using Microsoft.OpenApi;

namespace Shiny.Mediator.SourceGenerators;


public class OpenApiModelGenerator
{
    readonly MediatorHttpItemConfig config;
    readonly SourceProductionContext context;
    readonly Compilation compilation;
    readonly string accessor;
    readonly HashSet<string> generatedTypes = new();

    public OpenApiModelGenerator(MediatorHttpItemConfig config, SourceProductionContext context, Compilation compilation)
    {
        this.config = config;
        this.context = context;
        this.compilation = compilation;
        this.accessor = config.UseInternalClasses ? "internal" : "public";
    }

    public void GenerateModel(string name, OpenApiSchema schema)
    {
        var className = name.Pascalize();

        if (generatedTypes.Contains(className))
            return;

        generatedTypes.Add(className);

        if (schema.Enum?.Count > 0)
        {
            GenerateEnum(className, schema);
        }
        else if (schema.Type?.HasFlag(JsonSchemaType.Object) == true || schema.Properties?.Count > 0)
        {
            GenerateClass(className, schema);
        }
    }

    void GenerateEnum(string enumName, OpenApiSchema schema)
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated>");
        sb.AppendLine("// Code generated by Shiny Mediator OpenAPI Source Generator.");
        sb.AppendLine("// </auto-generated>");
        sb.AppendLine("#nullable disable");
        sb.AppendLine();
        sb.AppendLine($"namespace {config.Namespace};");
        sb.AppendLine();

        // Check if the first enum value is a string-based value
        var firstValue = schema.Enum?.FirstOrDefault();
        var isStringEnum = firstValue != null && firstValue.GetValueKind() == System.Text.Json.JsonValueKind.String;

        if (isStringEnum)
        {
            sb.AppendLine($"[global::System.Text.Json.Serialization.JsonConverter(typeof(global::System.Text.Json.Serialization.JsonStringEnumConverter<global::{config.Namespace}.{enumName}>))]");
        }

        sb.AppendLine(Constants.GeneratedCodeAttributeString);
        sb.AppendLine($"{accessor} enum {enumName}");
        sb.AppendLine("{");

        if (isStringEnum)
        {
            foreach (var ev in schema.Enum)
            {
                if (ev != null)
                {
                    var strValue = ev.GetValue<string>();
                    sb.AppendLine($"    {strValue},");
                }
            }
        }
        else
        {
            foreach (var ev in schema.Enum)
            {
                if (ev != null)
                {
                    var intValue = ev.GetValue<int>();
                    sb.AppendLine($"    Value{intValue} = {intValue},");
                }
            }
        }

        sb.AppendLine("}");

        context.AddSource($"{enumName}.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
    }

    void GenerateClass(string className, OpenApiSchema schema)
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated>");
        sb.AppendLine("// Code generated by Shiny Mediator OpenAPI Source Generator.");
        sb.AppendLine("// </auto-generated>");
        sb.AppendLine("#nullable disable");
        sb.AppendLine();
        sb.AppendLine($"namespace {config.Namespace};");
        sb.AppendLine();
        sb.AppendLine(Constants.GeneratedCodeAttributeString);
        sb.Append($"{accessor} partial class {className}");

        // Handle inheritance
        if (schema.AllOf?.Count == 1)
        {
            if (schema.AllOf[0] is OpenApiSchema baseSchema)
            {
                var baseType = GetSchemaType(baseSchema);
                if (baseType != null)
                {
                    sb.AppendLine($" : {baseType}");
                }
                else
                {
                    sb.AppendLine();
                }
            }
            else
            {
                sb.AppendLine();
            }
        }
        else
        {
            sb.AppendLine();
        }

        sb.AppendLine("{");

        // Generate properties
        if (schema.Properties != null)
        {
            foreach (var property in schema.Properties)
            {
                var propertyName = property.Key.Pascalize();
                var propSchema = property.Value as OpenApiSchema;
                
                if (propSchema == null)
                    continue;

                string? typeName;

                // Check if this is a nested object (no title means it's inline)
                var isObject = propSchema.Type?.HasFlag(JsonSchemaType.Object) == true;
                if (isObject && propSchema.Properties != null && string.IsNullOrEmpty(propSchema.Title))
                {
                    // Generate nested type
                    typeName = className + propertyName;
                    GenerateClass(typeName, propSchema);
                }
                else if (propSchema.Enum?.Count > 0 && string.IsNullOrEmpty(propSchema.Title))
                {
                    // Generate nested enum
                    typeName = className + propertyName;
                    GenerateEnum(typeName, propSchema);
                }
                else
                {
                    typeName = GetSchemaType(propSchema);
                }

                if (typeName != null)
                {
                    sb.AppendLine($"    [global::System.Text.Json.Serialization.JsonPropertyName(\"{property.Key}\")]");
                    sb.AppendLine($"    public {typeName} {propertyName} {{ get; set; }}");
                    sb.AppendLine();
                }
            }
        }

        sb.AppendLine("}");

        context.AddSource($"{className}.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));

        // Generate JSON converter if requested
        if (config.GenerateJsonConverters)
        {
            try
            {
                // Parse the generated source code and add it to compilation so we can get the type symbol
                var parseOptions = compilation.SyntaxTrees.FirstOrDefault()?.Options as Microsoft.CodeAnalysis.CSharp.CSharpParseOptions ?? Microsoft.CodeAnalysis.CSharp.CSharpParseOptions.Default;
                var syntaxTree = Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree.ParseText(
                    sb.ToString(), 
                    parseOptions,
                    cancellationToken: context.CancellationToken
                );
                var updatedCompilation = compilation.AddSyntaxTrees(syntaxTree);
                
                var fullyQualifiedTypeName = $"{config.Namespace}.{className}";
                var typeSymbol = updatedCompilation.GetTypeByMetadataName(fullyQualifiedTypeName);
                
                if (typeSymbol != null)
                {
                    JsonConverterSourceGenerator.GenerateJsonConverter(context, typeSymbol);
                }
            }
            catch
            {
                // If we can't generate the JSON converter, just skip it silently
                // This might happen for complex types or if there are other issues
            }
        }
    }

    string? GetSchemaType(OpenApiSchema schema)
    {
        string? type = null;

        // Check if this schema has a title (meaning it's a named type reference)
        if (!string.IsNullOrEmpty(schema.Title))
        {
            return $"global::{config.Namespace}.{schema.Title}";
        }

        if (schema.Type != null)
        {
            if (schema.Type.Value.HasFlag(JsonSchemaType.String))
            {
                type = GetStringType(schema);
            }
            else if (schema.Type.Value.HasFlag(JsonSchemaType.Integer))
            {
                type = GetNumberType(schema.Format);
            }
            else if (schema.Type.Value.HasFlag(JsonSchemaType.Number))
            {
                type = GetNumberType(schema.Format);
            }
            else if (schema.Type.Value.HasFlag(JsonSchemaType.Boolean))
            {
                type = "bool";
            }
            else if (schema.Type.Value.HasFlag(JsonSchemaType.Array))
            {
                var itemsSchema = schema.Items as OpenApiSchema;
                if (itemsSchema != null)
                {
                    var listType = GetSchemaType(itemsSchema);
                    return listType != null ? $"global::System.Collections.Generic.List<{listType}>" : null;
                }
            }
            else if (schema.Type.Value.HasFlag(JsonSchemaType.Object))
            {
                if (schema.AdditionalProperties == null)
                {
                    // Object with no additional properties and no title - might be inline definition
                    type = "object";
                }
                else
                {
                    var addPropsSchema = schema.AdditionalProperties as OpenApiSchema;
                    if (addPropsSchema != null)
                    {
                        var dictionaryValueType = GetSchemaType(addPropsSchema);
                        if (dictionaryValueType != null)
                            type = $"global::System.Collections.Generic.Dictionary<string, {dictionaryValueType}>";
                    }
                }
            }
            else
            {
                type = "object";
            }
        }
        else if (schema.AllOf?.Count == 1)
        {
            var allOfSchema = schema.AllOf[0] as OpenApiSchema;
            if (allOfSchema != null)
                type = GetSchemaType(allOfSchema);
        }

        return type;
    }

    static string GetStringType(OpenApiSchema schema)
    {
        if (schema.Pattern?.Equals("^-(\\d+\\.)?\\d{2}:\\d{2}:\\d{2}(\\.\\d{1,7})?$") ?? false)
            return "global::System.TimeSpan";

        return schema.Format switch
        {
            "date-time" => "global::System.DateTimeOffset",
            "uuid" => "global::System.Guid",
            "date" => "global::System.DateOnly",
            "time" => "global::System.TimeOnly",
            "date-span" => "global::System.TimeSpan",
            _ => "string"
        };
    }

    static string GetNumberType(string? format) => format switch
    {
        "int32" => "int",
        "int64" => "long",
        "float" => "float",
        _ => "double"
    };
}

