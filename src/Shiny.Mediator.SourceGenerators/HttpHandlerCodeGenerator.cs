using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Shiny.Mediator.SourceGenerators;

/// <summary>
/// Reusable code generator for HTTP request handlers
/// </summary>
internal static class HttpHandlerCodeGenerator
{
    public static string GenerateHandler(
        string handlerClassName,
        string requestTypeFullName,
        string resultTypeFullName,
        bool isStreamRequest,
        string httpMethod,
        string route,
        IEnumerable<HttpPropertyInfo> properties,
        bool implementsServerSentEvents,
        string targetNamespace
    )
    {
        // Materialize the properties once to avoid multiple enumeration
        var propertiesList = properties.ToList();
        
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated>");
        sb.AppendLine("// Code generated by Shiny Mediator HTTP Client Source Generator.");
        sb.AppendLine("// </auto-generated>");
        sb.AppendLine("#nullable disable");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Net.Http;");
        sb.AppendLine("using System.Threading;");
        sb.AppendLine("using System.Threading.Tasks;");
        
        if (isStreamRequest)
            sb.AppendLine("using System.Collections.Generic;");
        
        sb.AppendLine();
        sb.AppendLine($"namespace {targetNamespace};");
        sb.AppendLine();
        sb.AppendLine(Constants.GeneratedCodeAttributeString);

        if (isStreamRequest)
        {
            sb.AppendLine($"public partial class {handlerClassName}(global::Shiny.Mediator.Http.HttpHandlerServices services)");
            sb.AppendLine($"    : global::Shiny.Mediator.Http.BaseHttpRequestHandler(services),");
            sb.AppendLine($"      global::Shiny.Mediator.IStreamRequestHandler<{requestTypeFullName}, {resultTypeFullName}>");
            sb.AppendLine("{");
            sb.AppendLine($"    public global::System.Collections.Generic.IAsyncEnumerable<{resultTypeFullName}> Handle(");
            sb.AppendLine($"        {requestTypeFullName} request,");
            sb.AppendLine($"        global::Shiny.Mediator.IMediatorContext context,");
            sb.AppendLine($"        global::System.Threading.CancellationToken cancellationToken)");
            sb.AppendLine("    {");
        }
        else
        {
            sb.AppendLine($"public partial class {handlerClassName}(global::Shiny.Mediator.Http.HttpHandlerServices services)");
            sb.AppendLine($"    : global::Shiny.Mediator.Http.BaseHttpRequestHandler(services),");
            sb.AppendLine($"      global::Shiny.Mediator.IRequestHandler<{requestTypeFullName}, {resultTypeFullName}>");
            sb.AppendLine("{");
            sb.AppendLine($"    public global::System.Threading.Tasks.Task<{resultTypeFullName}> Handle(");
            sb.AppendLine($"        {requestTypeFullName} request,");
            sb.AppendLine($"        global::Shiny.Mediator.IMediatorContext context,");
            sb.AppendLine($"        global::System.Threading.CancellationToken cancellationToken)");
            sb.AppendLine("    {");
        }

        // Build the route with path parameters interpolated
        var routeExpression = BuildRouteExpression(route, propertiesList);
        sb.AppendLine($"        var route = {routeExpression};");
        
        // Add query parameters conditionally to route
        var queryProps = propertiesList.Where(p => p.ParameterType == HttpParameterType.Query).ToList();
        if (queryProps.Count > 0)
        {
            sb.AppendLine();
            foreach (var prop in queryProps)
            {
                sb.AppendLine($"        if (request.{prop.PropertyName} != null)");
                sb.AppendLine("        {");
                sb.AppendLine("            route += route.Contains(\"?\") ? \"&\" : \"?\";");
                sb.AppendLine($"            route += $\"{prop.ParameterName}={{request.{prop.PropertyName}}}\";");
                sb.AppendLine("        }");
                sb.AppendLine();
            }
        }
        else
        {
            sb.AppendLine();
        }
        
        // Create HTTP request message
        var httpMethodMapping = GetHttpMethodMapping(httpMethod);
        sb.AppendLine($"        var httpRequest = new global::System.Net.Http.HttpRequestMessage({httpMethodMapping}, route);");
        
        // Add headers
        var headerProps = propertiesList.Where(p => p.ParameterType == HttpParameterType.Header).ToList();
        if (headerProps.Count > 0)
        {
            sb.AppendLine();
            foreach (var prop in headerProps)
            {
                sb.AppendLine($"        if (request.{prop.PropertyName} != null)");
                sb.AppendLine($"            httpRequest.Headers.Add(\"{prop.ParameterName}\", request.{prop.PropertyName}.ToString());");
            }
        }

        // Add body if present
        var bodyProp = propertiesList.FirstOrDefault(p => p.ParameterType == HttpParameterType.Body);
        if (bodyProp != null)
        {
            sb.AppendLine();
            sb.AppendLine($"        if (request.{bodyProp.PropertyName} != null)");
            sb.AppendLine("        {");
            sb.AppendLine($"            var json = services.Serializer.Serialize(request.{bodyProp.PropertyName});");
            sb.AppendLine("            httpRequest.Content = new global::System.Net.Http.StringContent(json, global::System.Text.Encoding.UTF8, \"application/json\");");
            sb.AppendLine("        }");
        }

        sb.AppendLine();

        // Call base handler method
        if (isStreamRequest)
        {
            var useSse = implementsServerSentEvents ? "true" : "request is global::Shiny.Mediator.Http.IServerSentEventsStream";
            sb.AppendLine($"        return this.HandleStream<{requestTypeFullName}, {resultTypeFullName}>(");
            sb.AppendLine("            httpRequest,");
            sb.AppendLine("            request,");
            sb.AppendLine($"            {useSse},");
            sb.AppendLine("            context,");
            sb.AppendLine("            cancellationToken");
            sb.AppendLine("        );");
        }
        else
        {
            sb.AppendLine($"        return this.HandleRequest<{requestTypeFullName}, {resultTypeFullName}>(");
            sb.AppendLine("            httpRequest,");
            sb.AppendLine("            request,");
            sb.AppendLine("            context,");
            sb.AppendLine("            cancellationToken");
            sb.AppendLine("        );");
        }

        sb.AppendLine("    }");
        sb.AppendLine("}");

        return sb.ToString();
    }

    public static string GenerateRegistration(
        IEnumerable<HandlerRegistrationInfo> handlers,
        string targetNamespace,
        string registrationClassName,
        string registrationMethodName,
        bool useInternalAccessModifier
    )
    {
        var accessModifier = useInternalAccessModifier ? "internal" : "public";
        
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated>");
        sb.AppendLine("// Code generated by Shiny Mediator HTTP Client Source Generator.");
        sb.AppendLine("// </auto-generated>");
        sb.AppendLine("#nullable disable");
        sb.AppendLine();
        sb.AppendLine("using Shiny.Mediator;");
        sb.AppendLine("using Microsoft.Extensions.DependencyInjection;");
        sb.AppendLine("using Microsoft.Extensions.DependencyInjection.Extensions;");
        sb.AppendLine();
        sb.AppendLine($"namespace {targetNamespace};");
        sb.AppendLine();
        sb.AppendLine(Constants.GeneratedCodeAttributeString);
        sb.AppendLine($"{accessModifier} static class {registrationClassName}");
        sb.AppendLine("{");
        sb.AppendLine($"    public static global.Shiny.Mediator.ShinyMediatorBuilder {registrationMethodName}(this global::Shiny.Mediator.ShinyMediatorBuilder mediatorBuilder)");
        sb.AppendLine("    {");
        sb.AppendLine($"        mediatorBuilder.Services.{registrationMethodName}();");
        sb.AppendLine("        return mediatorBuilder;");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine($"    public static global::Microsoft.Extensions.DependencyInjection.IServiceCollection {registrationMethodName}(this global::Microsoft.Extensions.DependencyInjection.IServiceCollection services)");
        sb.AppendLine("    {");
        sb.AppendLine("        services.AddMediatorHttpClientServices();");

        foreach (var handler in handlers)
        {
            if (handler.IsStreamRequest)
            {
                sb.AppendLine($"        services.TryAddSingleton<global::Shiny.Mediator.IStreamRequestHandler<{handler.RequestTypeFullName}, {handler.ResultTypeFullName}>, {handler.HandlerTypeFullName}>();");
            }
            else
            {
                sb.AppendLine($"        services.TryAddSingleton<global::Shiny.Mediator.IRequestHandler<{handler.RequestTypeFullName}, {handler.ResultTypeFullName}>, {handler.HandlerTypeFullName}>();");
            }
        }

        sb.AppendLine("        return services;");
        sb.AppendLine("    }");
        sb.AppendLine("}");

        return sb.ToString();
    }

    static string BuildRouteExpression(string route, IEnumerable<HttpPropertyInfo> properties)
    {
        var propertiesList = properties.ToList();
        
        // Check if route contains any path parameters
        var hasPathParameters = route.Contains("{");
        
        if (!hasPathParameters)
        {
            return $"\"{route}\"";
        }
        
        // Replace path parameters with interpolation
        var result = route;
        foreach (var prop in propertiesList.Where(p => p.ParameterType == HttpParameterType.Path))
        {
            var routeParam = $"{{{prop.ParameterName}}}";
            // Check case-insensitive but replace case-sensitive
            var index = result.IndexOf(routeParam, StringComparison.OrdinalIgnoreCase);
            if (index >= 0)
            {
                var actualParam = result.Substring(index, routeParam.Length);
                result = result.Replace(actualParam, $"{{request.{prop.PropertyName}}}");
            }
        }
        
        return $"$\"{result}\"";
    }

    static string GetHttpMethodMapping(string httpMethod) => httpMethod.ToUpper() switch
    {
        "GET" => "global::System.Net.Http.HttpMethod.Get",
        "POST" => "global::System.Net.Http.HttpMethod.Post",
        "PUT" => "global::System.Net.Http.HttpMethod.Put",
        "PATCH" => "global::System.Net.Http.HttpMethod.Patch",
        "DELETE" => "global::System.Net.Http.HttpMethod.Delete",
        _ => $"new global::System.Net.Http.HttpMethod(\"{httpMethod}\")"
    };
}

public enum HttpParameterType
{
    Path,
    Query,
    Header,
    Body
}

public record HttpPropertyInfo(
    string PropertyName,
    string ParameterName,
    bool IsRequired,
    HttpParameterType ParameterType,
    string? PropertyType = null,
    string? Comments = null
);

public record HandlerRegistrationInfo(
    string HandlerTypeFullName,
    string RequestTypeFullName,
    string ResultTypeFullName,
    bool IsStreamRequest
);

