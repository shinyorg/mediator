using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Shiny.Mediator.SourceGenerators;


[Generator(LanguageNames.CSharp)]
public class MediatorSourceGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Register post initialization to generate the attributes
        context.RegisterPostInitializationOutput(ctx => ctx.AddSource(
            "MediatorAttributes.g.cs",
            SourceText.From(
                """
                    // <auto-generated>
                    // Code generated by Shiny Mediator Source Generator.
                    // Changes may cause incorrect behavior and will be lost if the code is
                    // regenerated.
                    // </auto-generated>
                    #nullable disable

                    $GENCODEATTRIBUTE$
                    [global::System.AttributeUsage(global::System.AttributeTargets.Class, AllowMultiple = false)]
                    internal sealed class MediatorSingletonAttribute : global::System.Attribute
                    {
                    }

                    $GENCODEATTRIBUTE$
                    [global::System.AttributeUsage(global::System.AttributeTargets.Class, AllowMultiple = false)]
                    internal sealed class MediatorScopedAttribute : global::System.Attribute
                    {
                    }
                    """.Replace("$GENCODEATTRIBUTE$", Constants.GeneratedCodeAttributeString),
                Encoding.UTF8
            )
        ));


        // Get MSBuild configuration options and infer assembly name from compilation
        var msbuildOptions = context.CompilationProvider
            .Combine(context.AnalyzerConfigOptionsProvider)
            .Select((pair, _) =>
            {
                var (compilation, provider) = pair;
                
                // Infer assembly name from compilation
                var assemblyName = compilation.AssemblyName ?? "Generated";
                
                provider.GlobalOptions.TryGetValue("build_property.RootNamespace", out var rootNamespace);
                provider.GlobalOptions.TryGetValue("build_property.ShinyMediatorRequestExecutorClassName", out var requestExecutorClassName);
                provider.GlobalOptions.TryGetValue("build_property.ShinyMediatorStreamRequestExecutorClassName", out var streamRequestExecutorClassName);
                provider.GlobalOptions.TryGetValue("build_property.ShinyMediatorRegistryMethodName", out var registryMethodName);
                provider.GlobalOptions.TryGetValue("build_property.ShinyMediatorRegistryAccessModifier", out var accessModifier);

                return new MsBuildOptions(
                    RootNamespace: rootNamespace,
                    AssemblyName: assemblyName,
                    RequestExecutorClassName: string.IsNullOrWhiteSpace(requestExecutorClassName) ? null : requestExecutorClassName,
                    StreamRequestExecutorClassName: string.IsNullOrWhiteSpace(streamRequestExecutorClassName) ? null : streamRequestExecutorClassName,
                    RegistryMethodName: string.IsNullOrWhiteSpace(registryMethodName) ? "AddMediatorRegistry" : registryMethodName!,
                    AccessModifier: string.IsNullOrWhiteSpace(accessModifier) ? "internal" : accessModifier!
                );
            });

        // Collect all handlers and middleware from current compilation ONLY
        var allHandlersAndMiddleware = context.CompilationProvider
            .Select((compilation, _) =>
            {

                var handlers = new List<HandlerInfo>();
                var middleware = new List<MiddlewareInfo>();

                // Scan ONLY current assembly (syntax trees) - NOT referenced assemblies
                foreach (var syntaxTree in compilation.SyntaxTrees)
                {
                    var semanticModel = compilation.GetSemanticModel(syntaxTree);
                    var root = syntaxTree.GetRoot();

                    var classDeclarations = root.DescendantNodes()
                        .OfType<ClassDeclarationSyntax>()
                        .Where(c => c.AttributeLists.Count > 0);

                    foreach (var classDecl in classDeclarations)
                    {
                        var symbol = semanticModel.GetDeclaredSymbol(classDecl);
                        if (symbol is INamedTypeSymbol classSymbol)
                        {
                            CollectHandlersAndMiddleware(classSymbol, handlers, middleware);
                        }
                    }
                }

                return (
                    Handlers: handlers.ToImmutableArray(), 
                    Middleware: middleware.ToImmutableArray()
                );
            });

        // Combine all data and generate output
        var combined = allHandlersAndMiddleware.Combine(msbuildOptions);

        context.RegisterSourceOutput(combined, static (spc, source) =>
        {
            var handlersAndMiddleware = source.Left;
            var options = source.Right;

            if (handlersAndMiddleware.Handlers.IsEmpty && handlersAndMiddleware.Middleware.IsEmpty)
                return;

            Execute(
                handlersAndMiddleware.Handlers,
                handlersAndMiddleware.Middleware,
                options,
                spc
            );
        });
    }


    static void CollectHandlersAndMiddleware(INamedTypeSymbol classSymbol, List<HandlerInfo> handlers,
        List<MiddlewareInfo> middleware)
    {
        // Check for MediatorSingleton or MediatorScoped attribute
        var singletonAttr = classSymbol
            .GetAttributes()
            .FirstOrDefault(a => a.AttributeClass?.Name == "MediatorSingletonAttribute");

        var scopedAttr = classSymbol
            .GetAttributes()
            .FirstOrDefault(a => a.AttributeClass?.Name == "MediatorScopedAttribute");

        if (singletonAttr is null && scopedAttr is null)
            return;

        var lifetime = singletonAttr is not null ? "Singleton" : "Scoped";

        // Check for handlers
        foreach (var iface in classSymbol.AllInterfaces)
        {
            if (iface is { Name: "IRequestHandler", TypeArguments.Length: 2 })
            {
                handlers.Add(new HandlerInfo(
                    ClassSymbol: classSymbol,
                    HandlerType: "Request",
                    RequestType: iface.TypeArguments[0],
                    ResultType: iface.TypeArguments[1],
                    Lifetime: lifetime
                ));
            }

            if (iface is { Name: "IStreamRequestHandler", TypeArguments.Length: 2 })
            {
                handlers.Add(new HandlerInfo(
                    ClassSymbol: classSymbol,
                    HandlerType: "Stream",
                    RequestType: iface.TypeArguments[0],
                    ResultType: iface.TypeArguments[1],
                    Lifetime: lifetime
                ));
            }

            if (iface is { Name: "ICommandHandler", TypeArguments.Length: 1 })
            {
                handlers.Add(new HandlerInfo(
                    ClassSymbol: classSymbol,
                    HandlerType: "Command",
                    RequestType: iface.TypeArguments[0],
                    ResultType: null,
                    Lifetime: lifetime
                ));
            }

            if (iface is { Name: "IEventHandler", TypeArguments.Length: 1 })
            {
                handlers.Add(new HandlerInfo(
                    ClassSymbol: classSymbol,
                    HandlerType: "Event",
                    RequestType: iface.TypeArguments[0],
                    ResultType: null,
                    Lifetime: lifetime
                ));
            }
        }

        // Check for middleware
        foreach (var iface in classSymbol.AllInterfaces)
        {
            if (iface is { Name: "IRequestMiddleware", TypeArguments.Length: 2 })
            {
                middleware.Add(new MiddlewareInfo(
                    ClassSymbol: classSymbol,
                    MiddlewareType: "Request",
                    RequestType: iface.TypeArguments[0],
                    ResultType: iface.TypeArguments[1],
                    Lifetime: lifetime
                ));
                return; // Only one middleware per class
            }

            if (iface is { Name: "IStreamRequestMiddleware", TypeArguments.Length: 2 })
            {
                middleware.Add(new MiddlewareInfo(
                    ClassSymbol: classSymbol,
                    MiddlewareType: "Stream",
                    RequestType: iface.TypeArguments[0],
                    ResultType: iface.TypeArguments[1],
                    Lifetime: lifetime
                ));
                return;
            }

            if (iface is { Name: "ICommandMiddleware", TypeArguments.Length: 1 })
            {
                middleware.Add(new MiddlewareInfo(
                    ClassSymbol: classSymbol,
                    MiddlewareType: "Command",
                    RequestType: iface.TypeArguments[0],
                    ResultType: null,
                    Lifetime: lifetime
                ));
                return;
            }

            if (iface is { Name: "IEventMiddleware", TypeArguments.Length: 1 })
            {
                middleware.Add(new MiddlewareInfo(
                    ClassSymbol: classSymbol,
                    MiddlewareType: "Event",
                    RequestType: iface.TypeArguments[0],
                    ResultType: null,
                    Lifetime: lifetime
                ));
                return;
            }
        }
    }


    static void Execute(
        ImmutableArray<HandlerInfo> handlers,
        ImmutableArray<MiddlewareInfo> middleware,
        MsBuildOptions options,
        SourceProductionContext context
    )
    {
        var requestHandlers = handlers.Where(h => h.HandlerType == "Request").ToList();
        var streamHandlers = handlers.Where(h => h.HandlerType == "Stream").ToList();

        // Use RootNamespace first, fallback to AssemblyName
        var namespaceName = !string.IsNullOrWhiteSpace(options.RootNamespace) 
            ? options.RootNamespace 
            : options.AssemblyName;
        
        var safeNamespaceName = namespaceName?.Replace(".", "") ?? "Generated";

        // Use custom class name or fallback to default
        var executorClassName = options.RequestExecutorClassName ?? $"{safeNamespaceName}RequestExecutor";
        var streamExecutorClassName = options.StreamRequestExecutorClassName ?? $"{safeNamespaceName}StreamRequestExecutor";

        // Generate RequestExecutor
        if (requestHandlers.Count > 0)
        {
            var requestExecutorCode = GenerateRequestExecutor(requestHandlers, namespaceName, executorClassName);
            context.AddSource($"{safeNamespaceName}_RequestExecutor.g.cs",
                SourceText.From(requestExecutorCode, Encoding.UTF8));
        }

        // Generate StreamRequestExecutor
        if (streamHandlers.Count > 0)
        {
            var streamExecutorCode = GenerateStreamRequestExecutor(streamHandlers, namespaceName, streamExecutorClassName);
            context.AddSource($"{safeNamespaceName}_StreamRequestExecutor.g.cs", SourceText.From(streamExecutorCode, Encoding.UTF8));
        }

        // Generate registry extension method
        var registryCode = GenerateRegistry(
            handlers.ToList(),
            middleware.ToList(),
            namespaceName,
            requestHandlers.Count > 0,
            streamHandlers.Count > 0,
            executorClassName,
            streamExecutorClassName,
            options
        );
        context.AddSource($"{safeNamespaceName}_Registry.g.cs", SourceText.From(registryCode, Encoding.UTF8));
    }


    static string GenerateRequestExecutor(List<HandlerInfo> handlers, string? namespaceName, string executorClassName)
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated>");
        sb.AppendLine("// Code generated by Shiny Mediator Source Generator.");
        sb.AppendLine("// </auto-generated>");
        sb.AppendLine("#nullable disable");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Threading;");
        sb.AppendLine("using System.Threading.Tasks;");
        sb.AppendLine();

        if (namespaceName is not null)
        {
            sb.AppendLine($"namespace {namespaceName};");
            sb.AppendLine();
        }

        sb.AppendLine(Constants.GeneratedCodeAttributeString);
        sb.AppendLine($"internal class {executorClassName} : global::Shiny.Mediator.Infrastructure.RequestExecutor");
        sb.AppendLine("{");

        // Request method
        sb.AppendLine("    public override async global::System.Threading.Tasks.Task<TResult> Request<TResult>(");
        sb.AppendLine("        global::Shiny.Mediator.IMediatorContext context,");
        sb.AppendLine("        global::Shiny.Mediator.IRequest<TResult> request,");
        sb.AppendLine("        global::System.Threading.CancellationToken cancellationToken)");
        sb.AppendLine("    {");

        for (int i = 0; i < handlers.Count; i++)
        {
            var handler = handlers[i];
            var requestTypeFull = GetFullTypeName(handler.RequestType);
            var resultTypeFull = GetFullTypeName(handler.ResultType);

            sb.AppendLine($"        if (request is {requestTypeFull} p{i})");
            sb.AppendLine("        {");
            sb.AppendLine($"            object result = await this.Execute<{requestTypeFull}, {resultTypeFull}>(p{i}, context, cancellationToken);");
            sb.AppendLine( "            return (TResult)result;");
            sb.AppendLine("        }");
            sb.AppendLine();
        }

        sb.AppendLine("        throw new global::System.InvalidOperationException(\"Unknown request type\");");
        sb.AppendLine("    }");
        sb.AppendLine();

        // CanHandle method
        sb.AppendLine("    public override bool CanHandle<TResult>(global::Shiny.Mediator.IRequest<TResult> request)");
        sb.AppendLine("    {");

        for (var i = 0; i < handlers.Count; i++)
        {
            var handler = handlers[i];
            var requestTypeFull = GetFullTypeName(handler.RequestType);
            sb.AppendLine($"        if (request is {requestTypeFull})");
            sb.AppendLine( "            return true;");
            sb.AppendLine();
        }

        sb.AppendLine("        return false;");
        sb.AppendLine("    }");
        sb.AppendLine("}");

        return sb.ToString();
    }


    static string GenerateStreamRequestExecutor(List<HandlerInfo> handlers, string? namespaceName,
        string streamExecutorClassName)
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated>");
        sb.AppendLine("// Code generated by Shiny Mediator Source Generator.");
        sb.AppendLine("// </auto-generated>");
        sb.AppendLine("#nullable disable");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using System.Threading;");
        sb.AppendLine();

        if (namespaceName is not null)
        {
            sb.AppendLine($"namespace {namespaceName};");
            sb.AppendLine();
        }

        sb.AppendLine(Constants.GeneratedCodeAttributeString);
        sb.AppendLine(
            $"internal class {streamExecutorClassName} : global::Shiny.Mediator.Infrastructure.StreamRequestExecutor");
        sb.AppendLine("{");

        // Request method
        sb.AppendLine("    public override global::System.Collections.Generic.IAsyncEnumerable<TResult> Request<TResult>(");
        sb.AppendLine("        global::Shiny.Mediator.IMediatorContext context,");
        sb.AppendLine("        global::Shiny.Mediator.IStreamRequest<TResult> request,");
        sb.AppendLine("        global::System.Threading.CancellationToken cancellationToken");
        sb.AppendLine("    )");
        sb.AppendLine("    {");

        for (var i = 0; i < handlers.Count; i++)
        {
            var handler = handlers[i];
            var requestTypeFull = GetFullTypeName(handler.RequestType);
            var resultTypeFull = GetFullTypeName(handler.ResultType);

            sb.AppendLine($"        if (request is {requestTypeFull} p{i})");
            sb.AppendLine("        {");
            sb.AppendLine($"            var handle = this.Execute<{requestTypeFull}, {resultTypeFull}>(context, p{i}, cancellationToken);");
            sb.AppendLine("            return (global::System.Collections.Generic.IAsyncEnumerable<TResult>)handle;");
            sb.AppendLine("        }");
            sb.AppendLine();
        }

        sb.AppendLine("        throw new global::System.InvalidOperationException(\"Unknown request type\");");
        sb.AppendLine("    }");
        sb.AppendLine();

        // CanRequest method
        sb.AppendLine("    public override bool CanRequest<TResult>(global::Shiny.Mediator.IStreamRequest<TResult> request)");
        sb.AppendLine("    {");

        for (var i = 0; i < handlers.Count; i++)
        {
            var handler = handlers[i];
            var requestTypeFull = GetFullTypeName(handler.RequestType);
            sb.AppendLine($"        if (request is {requestTypeFull})");
            sb.AppendLine("            return true;");
            sb.AppendLine();
        }

        sb.AppendLine("        return false;");
        sb.AppendLine("    }");
        sb.AppendLine("}");

        return sb.ToString();
    }


    static string GenerateRegistry(
        List<HandlerInfo> handlers,
        List<MiddlewareInfo> middleware,
        string? namespaceName,
        bool hasRequestHandlers,
        bool hasStreamHandlers,
        string executorClassName,
        string streamExecutorClassName,
        MsBuildOptions options
    )
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated>");
        sb.AppendLine("// Code generated by Shiny Mediator Source Generator.");
        sb.AppendLine("// </auto-generated>");
        sb.AppendLine("#nullable disable");
        sb.AppendLine();
        sb.AppendLine("using Shiny.Mediator;");
        sb.AppendLine("using Microsoft.Extensions.DependencyInjection;");
        sb.AppendLine();

        if (namespaceName is not null)
        {
            sb.AppendLine($"namespace {namespaceName};");
            sb.AppendLine();
        }

        sb.AppendLine(Constants.GeneratedCodeAttributeString);
        sb.AppendLine($"{options.AccessModifier} static class __ShinyMediatorRegistry");
        sb.AppendLine("{");
        sb.AppendLine($"    public static global::Microsoft.Extensions.DependencyInjection.IServiceCollection {options.RegistryMethodName}(this global::Microsoft.Extensions.DependencyInjection.IServiceCollection services)");
        sb.AppendLine("    {");

        // Register handlers - deduplicate by class symbol
        var uniqueHandlers = handlers
            .GroupBy(h => h.ClassSymbol, SymbolEqualityComparer.Default)
            .Select(g => g.First())
            .ToList();

        foreach (var handler in uniqueHandlers)
        {
            var handlerTypeFull = GetFullTypeName(handler.ClassSymbol);
            var methodName = handler.Lifetime == "Singleton"
                ? "AddSingletonAsImplementedInterfaces"
                : "AddScopedAsImplementedInterfaces";
            sb.AppendLine($"        services.{methodName}<{handlerTypeFull}>();");
        }

        if (uniqueHandlers.Count > 0 && middleware.Count > 0)
        {
            sb.AppendLine();
        }

        // Register middleware
        foreach (var mw in middleware)
        {
            var isOpenGeneric = mw.ClassSymbol is { IsGenericType: true, TypeParameters.Length: > 0 };
            var methodName = mw.Lifetime == "Singleton" ? "AddSingleton" : "AddScoped";

            if (isOpenGeneric)
            {
                // Open generic registration
                var interfaceName = GetMiddlewareInterfaceName(mw.MiddlewareType);
                var typeParamCount = mw.MiddlewareType == "Request" || mw.MiddlewareType == "Stream" ? 2 : 1;
                var typeParams = new string(Enumerable.Repeat(',', typeParamCount - 1).ToArray());

                var classTypeName = GetOpenGenericTypeName(mw.ClassSymbol);
                sb.AppendLine($"        services.{methodName}(typeof({interfaceName}<{typeParams}>), typeof({classTypeName}<{typeParams}>));");
            }
            else
            {
                // Closed generic or non-generic registration
                var interfaceName = GetMiddlewareInterfaceName(mw.MiddlewareType);
                var classTypeFull = GetFullTypeName(mw.ClassSymbol);

                if (mw.MiddlewareType is "Request" or "Stream")
                {
                    var requestTypeFull = GetFullTypeName(mw.RequestType);
                    var resultTypeFull = GetFullTypeName(mw.ResultType);
                    sb.AppendLine($"        services.{methodName}<{interfaceName}<{requestTypeFull}, {resultTypeFull}>, {classTypeFull}>();");
                }
                else
                {
                    var requestTypeFull = GetFullTypeName(mw.RequestType);
                    sb.AppendLine($"        services.{methodName}<{interfaceName}<{requestTypeFull}>, {classTypeFull}>();");
                }
            }
        }

        if ((uniqueHandlers.Count > 0 || middleware.Count > 0) && (hasRequestHandlers || hasStreamHandlers))
            sb.AppendLine();

        // Register executors - use fully qualified type names
        var executorNamespace = namespaceName is not null ? $"{namespaceName}." : "";

        if (hasRequestHandlers)
            sb.AppendLine($"        services.AddSingleton<global::Shiny.Mediator.Infrastructure.IRequestExecutor, global::{executorNamespace}{executorClassName}>();");

        if (hasStreamHandlers)
            sb.AppendLine($"        services.AddSingleton<global::Shiny.Mediator.Infrastructure.IStreamRequestExecutor, global::{executorNamespace}{streamExecutorClassName}>();");

        sb.AppendLine();
        sb.AppendLine("        return services;");
        sb.AppendLine("    }");
        sb.AppendLine("}");

        return sb.ToString();
    }


    static string GetMiddlewareInterfaceName(string middlewareType) => middlewareType switch
    {
        "Request" => "global::Shiny.Mediator.IRequestMiddleware",
        "Stream" => "global::Shiny.Mediator.IStreamRequestMiddleware",
        "Command" => "global::Shiny.Mediator.ICommandMiddleware",
        "Event" => "global::Shiny.Mediator.IEventMiddleware",
        _ => throw new InvalidOperationException($"Unknown middleware type: {middlewareType}")
    };


    static string GetOpenGenericTypeName(INamedTypeSymbol typeSymbol)
    {
        var namespaceName = typeSymbol.ContainingNamespace?.ToDisplayString();
        var typeName = typeSymbol.Name;

        if (string.IsNullOrEmpty(namespaceName) || namespaceName == "<global namespace>")
            return $"global::{typeName}";

        return $"global::{namespaceName}.{typeName}";
    }


    static string GetFullTypeName(ITypeSymbol? typeSymbol)
    {
        if (typeSymbol == null)
            return String.Empty;

        return typeSymbol.ToDisplayString(
            SymbolDisplayFormat.FullyQualifiedFormat.WithGlobalNamespaceStyle(
                SymbolDisplayGlobalNamespaceStyle.Included
            )
        );
    }


    record struct HandlerInfo(
        INamedTypeSymbol ClassSymbol,
        string HandlerType,
        ITypeSymbol RequestType,
        ITypeSymbol? ResultType,
        string Lifetime
    );

    record struct MiddlewareInfo(
        INamedTypeSymbol ClassSymbol,
        string MiddlewareType,
        ITypeSymbol RequestType,
        ITypeSymbol? ResultType,
        string Lifetime
    );

    record struct MsBuildOptions(
        string? RootNamespace,
        string AssemblyName,
        string? RequestExecutorClassName,
        string? StreamRequestExecutorClassName,
        string RegistryMethodName,
        string AccessModifier
    );
}

