using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Shiny.Mediator.SourceGenerators;


[Generator(LanguageNames.CSharp)]
public class MediatorSourceGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Register post initialization to generate the assembly attribute
        context.RegisterPostInitializationOutput(ctx => ctx.AddSource(
            "MediatorAttributes.g.cs",
            SourceText.From(
                """
                    // <auto-generated>
                    // Code generated by Shiny Mediator Source Generator.
                    // Changes may cause incorrect behavior and will be lost if the code is
                    // regenerated.
                    // </auto-generated>
                    #nullable disable

                    $GENCODEATTRIBUTE$
                    [global::System.AttributeUsage(global::System.AttributeTargets.Assembly, AllowMultiple = false)]
                    internal sealed class ShinyMediatorHeadGenerationAttribute : global::System.Attribute 
                    {
                    }

                    $GENCODEATTRIBUTE$
                    [global::System.AttributeUsage(global::System.AttributeTargets.Class, AllowMultiple = false)]
                    internal sealed class MediatorSingletonAttribute : global::System.Attribute
                    {
                    }

                    $GENCODEATTRIBUTE$
                    [global::System.AttributeUsage(global::System.AttributeTargets.Class, AllowMultiple = false)]
                    internal sealed class MediatorScopedAttribute : global::System.Attribute
                    {
                    }
                    """.Replace("$GENCODEATTRIBUTE$", Constants.GeneratedCodeAttributeString),
                Encoding.UTF8
            )
        ));

        // Check if generation is enabled via assembly attribute or MSBuild property
        var generationEnabled = context.CompilationProvider
            .Combine(context.AnalyzerConfigOptionsProvider)
            .Select((pair, _) =>
            {
                var (compilation, options) = pair;

                // Check MSBuild property
                if (options.GlobalOptions.TryGetValue("build_property.ShinyMediatorHeadGeneration", out var msbuildValue)
                    && bool.TryParse(msbuildValue, out var enabled)
                    && enabled)
                {
                    return true;
                }

                // Check assembly attribute
                var hasAttribute = compilation.Assembly
                    .GetAttributes()
                    .Any(a => a.AttributeClass?.Name == "ShinyMediatorHeadGenerationAttribute");

                return hasAttribute;
            });

        var rootNamespace = context.AnalyzerConfigOptionsProvider
            .Select((provider, _) => provider.GlobalOptions.TryGetValue("build_property.RootNamespace", out var value)
                ? value
                : "");

        var requestExecutorClassName = context.AnalyzerConfigOptionsProvider
            .Select((provider, _) =>
                provider.GlobalOptions.TryGetValue("build_property.ShinyRequestExecutorClassName", out var value) &&
                !string.IsNullOrWhiteSpace(value)
                    ? value
                    : null);

        var streamRequestExecutorClassName = context.AnalyzerConfigOptionsProvider
            .Select((provider, _) =>
                provider.GlobalOptions.TryGetValue("build_property.ShinyStreamRequestExecutorClassName",
                    out var value) && !string.IsNullOrWhiteSpace(value)
                    ? value
                    : null);

        // Collect all handlers and middleware from current compilation and referenced assemblies
        var allHandlersAndMiddleware = context.CompilationProvider
            .Combine(generationEnabled)
            .Select((pair, _) =>
            {
                var (compilation, enabled) = pair;

                if (!enabled)
                    return (Handlers: ImmutableArray<HandlerInfo>.Empty,
                        Middleware: ImmutableArray<MiddlewareInfo>.Empty);

                var handlers = new List<HandlerInfo>();
                var middleware = new List<MiddlewareInfo>();

                // Scan current assembly (syntax trees)
                foreach (var syntaxTree in compilation.SyntaxTrees)
                {
                    var semanticModel = compilation.GetSemanticModel(syntaxTree);
                    var root = syntaxTree.GetRoot();

                    var classDeclarations = root.DescendantNodes()
                        .OfType<ClassDeclarationSyntax>()
                        .Where(c => c.AttributeLists.Count > 0);

                    foreach (var classDecl in classDeclarations)
                    {
                        var symbol = semanticModel.GetDeclaredSymbol(classDecl);
                        if (symbol is INamedTypeSymbol classSymbol)
                        {
                            CollectHandlersAndMiddleware(classSymbol, handlers, middleware);
                        }
                    }
                }

                // Scan all referenced assemblies (excluding .NET BCL)
                foreach (var reference in compilation.References)
                {
                    var assemblySymbol = compilation.GetAssemblyOrModuleSymbol(reference) as IAssemblySymbol;
                    if (assemblySymbol != null && !IsSystemAssembly(assemblySymbol))
                    {
                        ScanAssembly(assemblySymbol.GlobalNamespace, handlers, middleware);
                    }
                }

                return (Handlers: handlers.ToImmutableArray(), Middleware: middleware.ToImmutableArray());
            });

        // Combine all data and generate output
        var combined = allHandlersAndMiddleware
            .Combine(rootNamespace)
            .Combine(requestExecutorClassName)
            .Combine(streamRequestExecutorClassName);

        context.RegisterSourceOutput(combined, static (spc, source) =>
        {
            var handlersAndMiddleware = source.Left.Left.Left;
            var rootNamespace = source.Left.Left.Right;
            var requestExecutorClassName = source.Left.Right;
            var streamRequestExecutorClassName = source.Right;

            if (handlersAndMiddleware.Handlers.IsEmpty && handlersAndMiddleware.Middleware.IsEmpty)
                return;

            Execute(
                handlersAndMiddleware.Handlers,
                handlersAndMiddleware.Middleware,
                rootNamespace,
                requestExecutorClassName,
                streamRequestExecutorClassName,
                spc
            );
        });
    }


    static bool IsSystemAssembly(IAssemblySymbol assembly)
    {
        var assemblyName = assembly.Name;
        
        // Skip common .NET BCL assemblies
        return assemblyName.StartsWith("System.", StringComparison.Ordinal) ||
               assemblyName.StartsWith("Microsoft.", StringComparison.Ordinal) ||
               assemblyName.Equals("System", StringComparison.Ordinal) ||
               assemblyName.Equals("mscorlib", StringComparison.Ordinal) ||
               assemblyName.Equals("netstandard", StringComparison.Ordinal) ||
               assemblyName.StartsWith("Windows.", StringComparison.Ordinal) ||
               assemblyName.StartsWith("Mono.", StringComparison.Ordinal) ||
               assemblyName.StartsWith("Java.", StringComparison.Ordinal);
    }


    static void ScanAssembly(INamespaceSymbol namespaceSymbol, List<HandlerInfo> handlers, List<MiddlewareInfo> middleware)
    {
        foreach (var member in namespaceSymbol.GetMembers())
        {
            if (member is INamespaceSymbol childNamespace)
            {
                ScanAssembly(childNamespace, handlers, middleware);
            }
            else if (member is INamedTypeSymbol typeSymbol)
            {
                CollectHandlersAndMiddleware(typeSymbol, handlers, middleware);

                // Scan nested types
                ScanNestedTypes(typeSymbol, handlers, middleware);
            }
        }
    }


    static void ScanNestedTypes(INamedTypeSymbol typeSymbol, List<HandlerInfo> handlers, List<MiddlewareInfo> middleware)
    {
        foreach (var nestedType in typeSymbol.GetTypeMembers())
        {
            CollectHandlersAndMiddleware(nestedType, handlers, middleware);
            ScanNestedTypes(nestedType, handlers, middleware);
        }
    }


    static void CollectHandlersAndMiddleware(INamedTypeSymbol classSymbol, List<HandlerInfo> handlers,
        List<MiddlewareInfo> middleware)
    {
        // Check for MediatorSingleton or MediatorScoped attribute
        var singletonAttr = classSymbol
            .GetAttributes()
            .FirstOrDefault(a => a.AttributeClass?.Name == "MediatorSingletonAttribute");

        var scopedAttr = classSymbol
            .GetAttributes()
            .FirstOrDefault(a => a.AttributeClass?.Name == "MediatorScopedAttribute");

        if (singletonAttr is null && scopedAttr is null)
            return;

        var lifetime = singletonAttr is not null ? "Singleton" : "Scoped";

        // Check for handlers
        foreach (var iface in classSymbol.AllInterfaces)
        {
            if (iface is { Name: "IRequestHandler", TypeArguments.Length: 2 })
            {
                handlers.Add(new HandlerInfo(
                    ClassSymbol: classSymbol,
                    HandlerType: "Request",
                    RequestType: iface.TypeArguments[0],
                    ResultType: iface.TypeArguments[1],
                    Lifetime: lifetime
                ));
            }

            if (iface is { Name: "IStreamRequestHandler", TypeArguments.Length: 2 })
            {
                handlers.Add(new HandlerInfo(
                    ClassSymbol: classSymbol,
                    HandlerType: "Stream",
                    RequestType: iface.TypeArguments[0],
                    ResultType: iface.TypeArguments[1],
                    Lifetime: lifetime
                ));
            }

            if (iface is { Name: "ICommandHandler", TypeArguments.Length: 1 })
            {
                handlers.Add(new HandlerInfo(
                    ClassSymbol: classSymbol,
                    HandlerType: "Command",
                    RequestType: iface.TypeArguments[0],
                    ResultType: null,
                    Lifetime: lifetime
                ));
            }

            if (iface is { Name: "IEventHandler", TypeArguments.Length: 1 })
            {
                handlers.Add(new HandlerInfo(
                    ClassSymbol: classSymbol,
                    HandlerType: "Event",
                    RequestType: iface.TypeArguments[0],
                    ResultType: null,
                    Lifetime: lifetime
                ));
            }
        }

        // Check for middleware
        foreach (var iface in classSymbol.AllInterfaces)
        {
            if (iface is { Name: "IRequestMiddleware", TypeArguments.Length: 2 })
            {
                middleware.Add(new MiddlewareInfo(
                    ClassSymbol: classSymbol,
                    MiddlewareType: "Request",
                    RequestType: iface.TypeArguments[0],
                    ResultType: iface.TypeArguments[1],
                    Lifetime: lifetime
                ));
                return; // Only one middleware per class
            }

            if (iface is { Name: "IStreamRequestMiddleware", TypeArguments.Length: 2 })
            {
                middleware.Add(new MiddlewareInfo(
                    ClassSymbol: classSymbol,
                    MiddlewareType: "Stream",
                    RequestType: iface.TypeArguments[0],
                    ResultType: iface.TypeArguments[1],
                    Lifetime: lifetime
                ));
                return;
            }

            if (iface is { Name: "ICommandMiddleware", TypeArguments.Length: 1 })
            {
                middleware.Add(new MiddlewareInfo(
                    ClassSymbol: classSymbol,
                    MiddlewareType: "Command",
                    RequestType: iface.TypeArguments[0],
                    ResultType: null,
                    Lifetime: lifetime
                ));
                return;
            }

            if (iface is { Name: "IEventMiddleware", TypeArguments.Length: 1 })
            {
                middleware.Add(new MiddlewareInfo(
                    ClassSymbol: classSymbol,
                    MiddlewareType: "Event",
                    RequestType: iface.TypeArguments[0],
                    ResultType: null,
                    Lifetime: lifetime
                ));
                return;
            }
        }
    }


    static void Execute(
        ImmutableArray<HandlerInfo> handlers,
        ImmutableArray<MiddlewareInfo> middleware,
        string rootNamespace,
        string? requestExecutorClassName,
        string? streamRequestExecutorClassName,
        SourceProductionContext context)
    {
        var requestHandlers = handlers.Where(h => h.HandlerType == "Request").ToList();
        var streamHandlers = handlers.Where(h => h.HandlerType == "Stream").ToList();

        var namespaceName = string.IsNullOrWhiteSpace(rootNamespace) ? null : rootNamespace;
        var safeNamespaceName = namespaceName?.Replace(".", "") ?? "Generated";

        // Use custom class name or fallback to default
        var executorClassName = requestExecutorClassName ?? $"{safeNamespaceName}RequestExecutor";
        var streamExecutorClassName = streamRequestExecutorClassName ?? $"{safeNamespaceName}StreamRequestExecutor";

        // Generate RequestExecutor
        if (requestHandlers.Count > 0)
        {
            var requestExecutorCode = GenerateRequestExecutor(requestHandlers, namespaceName, executorClassName);
            context.AddSource($"{safeNamespaceName}_RequestExecutor.g.cs",
                SourceText.From(requestExecutorCode, Encoding.UTF8));
        }

        // Generate StreamRequestExecutor
        if (streamHandlers.Count > 0)
        {
            var streamExecutorCode =
                GenerateStreamRequestExecutor(streamHandlers, namespaceName, streamExecutorClassName);
            context.AddSource($"{safeNamespaceName}_StreamRequestExecutor.g.cs",
                SourceText.From(streamExecutorCode, Encoding.UTF8));
        }

        // Generate module initializer
        var registryCode = GenerateModuleInitializer(
            handlers.ToList(),
            middleware.ToList(),
            namespaceName,
            safeNamespaceName,
            requestHandlers.Count > 0,
            streamHandlers.Count > 0,
            executorClassName,
            streamExecutorClassName
        );
        context.AddSource($"{safeNamespaceName}_Registry.g.cs", SourceText.From(registryCode, Encoding.UTF8));
    }


    static string GenerateRequestExecutor(List<HandlerInfo> handlers, string? namespaceName, string executorClassName)
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated>");
        sb.AppendLine("// Code generated by Shiny Mediator Source Generator.");
        sb.AppendLine("// </auto-generated>");
        sb.AppendLine("#nullable disable");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Threading;");
        sb.AppendLine("using System.Threading.Tasks;");
        sb.AppendLine();

        if (namespaceName is not null)
        {
            sb.AppendLine($"namespace {namespaceName};");
            sb.AppendLine();
        }

        sb.AppendLine(Constants.GeneratedCodeAttributeString);
        sb.AppendLine($"internal class {executorClassName} : global::Shiny.Mediator.Infrastructure.RequestExecutor");
        sb.AppendLine("{");

        // Request method
        sb.AppendLine("    public override async global::System.Threading.Tasks.Task<TResult> Request<TResult>(");
        sb.AppendLine("        global::Shiny.Mediator.IMediatorContext context,");
        sb.AppendLine("  global::Shiny.Mediator.IRequest<TResult> request,");
        sb.AppendLine(" global::System.Threading.CancellationToken cancellationToken)");
        sb.AppendLine("    {");

        for (int i = 0; i < handlers.Count; i++)
        {
            var handler = handlers[i];
            var requestTypeFull = GetFullTypeName(handler.RequestType);
            var resultTypeFull = GetFullTypeName(handler.ResultType);

            sb.AppendLine($"      if (request is {requestTypeFull} p{i})");
            sb.AppendLine("        {");
            sb.AppendLine(
                $"          object result = await this.Execute<{requestTypeFull}, {resultTypeFull}>(p{i}, context, cancellationToken);");
            sb.AppendLine("    return (TResult)result;");
            sb.AppendLine("        }");
            sb.AppendLine();
        }

        sb.AppendLine(" throw new global::System.InvalidOperationException(\"Unknown request type\");");
        sb.AppendLine("    }");
        sb.AppendLine();

        // CanHandle method
        sb.AppendLine("    public override bool CanHandle<TResult>(global::Shiny.Mediator.IRequest<TResult> request)");
        sb.AppendLine("    {");

        for (int i = 0; i < handlers.Count; i++)
        {
            var handler = handlers[i];
            var requestTypeFull = GetFullTypeName(handler.RequestType);
            sb.AppendLine($"      if (request is {requestTypeFull})");
            sb.AppendLine("     return true;");
            sb.AppendLine();
        }

        sb.AppendLine("        return false;");
        sb.AppendLine("    }");
        sb.AppendLine("}");

        return sb.ToString();
    }


    static string GenerateStreamRequestExecutor(List<HandlerInfo> handlers, string? namespaceName,
        string streamExecutorClassName)
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated>");
        sb.AppendLine("// Code generated by Shiny Mediator Source Generator.");
        sb.AppendLine("// </auto-generated>");
        sb.AppendLine("#nullable disable");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using System.Threading;");
        sb.AppendLine();

        if (namespaceName is not null)
        {
            sb.AppendLine($"namespace {namespaceName};");
            sb.AppendLine();
        }

        sb.AppendLine(Constants.GeneratedCodeAttributeString);
        sb.AppendLine(
            $"internal class {streamExecutorClassName} : global::Shiny.Mediator.Infrastructure.StreamRequestExecutor");
        sb.AppendLine("{");

        // Request method
        sb.AppendLine("    public override global::System.Collections.Generic.IAsyncEnumerable<TResult> Request<TResult>(");
        sb.AppendLine("        global::Shiny.Mediator.IMediatorContext context,");
        sb.AppendLine("        global::Shiny.Mediator.IStreamRequest<TResult> request,");
        sb.AppendLine("        global::System.Threading.CancellationToken cancellationToken");
        sb.AppendLine("    )");
        sb.AppendLine("    {");

        for (var i = 0; i < handlers.Count; i++)
        {
            var handler = handlers[i];
            var requestTypeFull = GetFullTypeName(handler.RequestType);
            var resultTypeFull = GetFullTypeName(handler.ResultType);

            sb.AppendLine($"      if (request is {requestTypeFull} p{i})");
            sb.AppendLine("        {");
            sb.AppendLine($"   var handle = this.Execute<{requestTypeFull}, {resultTypeFull}>(context, p{i}, cancellationToken);");
            sb.AppendLine("       return (global::System.Collections.Generic.IAsyncEnumerable<TResult>)handle;");
            sb.AppendLine(" }");
            sb.AppendLine();
        }

        sb.AppendLine("        throw new global::System.InvalidOperationException(\"Unknown request type\");");
        sb.AppendLine("    }");
        sb.AppendLine();

        // CanRequest method
        sb.AppendLine("    public override bool CanRequest<TResult>(global::Shiny.Mediator.IStreamRequest<TResult> request)");
        sb.AppendLine("    {");

        for (var i = 0; i < handlers.Count; i++)
        {
            var handler = handlers[i];
            var requestTypeFull = GetFullTypeName(handler.RequestType);
            sb.AppendLine($"        if (request is {requestTypeFull})");
            sb.AppendLine("        return true;");
            sb.AppendLine();
        }

        sb.AppendLine("        return false;");
        sb.AppendLine("    }");
        sb.AppendLine("}");

        return sb.ToString();
    }


    static string GenerateModuleInitializer(
        List<HandlerInfo> handlers,
        List<MiddlewareInfo> middleware,
        string? namespaceName,
        string safeNamespaceName,
        bool hasRequestHandlers,
        bool hasStreamHandlers,
        string executorClassName,
        string streamExecutorClassName)
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated>");
        sb.AppendLine("// Code generated by Shiny Mediator Source Generator.");
        sb.AppendLine("// </auto-generated>");
        sb.AppendLine("#nullable disable");
        sb.AppendLine();
        sb.AppendLine("using Shiny.Mediator;");
        sb.AppendLine("using Microsoft.Extensions.DependencyInjection;");
        sb.AppendLine();

        sb.AppendLine(Constants.GeneratedCodeAttributeString);
        sb.AppendLine("internal static class __ShinyMediatorRegistryFromReferences");
        sb.AppendLine("{");
        sb.AppendLine("    [global::System.Runtime.CompilerServices.ModuleInitializer]");
        sb.AppendLine("    public static void Run()");
        sb.AppendLine("    {");
        sb.AppendLine("        global::Shiny.Mediator.Infrastructure.MediatorRegistry.RegisterCallback(builder =>");
        sb.AppendLine("        {");

        // Register handlers - deduplicate by class symbol
        var uniqueHandlers = handlers
            .GroupBy(h => h.ClassSymbol, SymbolEqualityComparer.Default)
            .Select(g => g.First())
            .ToList();

        foreach (var handler in uniqueHandlers)
        {
            var handlerTypeFull = GetFullTypeName(handler.ClassSymbol);
            var methodName = handler.Lifetime == "Singleton"
                ? "AddSingletonAsImplementedInterfaces"
                : "AddScopedAsImplementedInterfaces";
            sb.AppendLine($"         builder.Services.{methodName}<{handlerTypeFull}>();");
        }

        if (uniqueHandlers.Count > 0 && middleware.Count > 0)
        {
            sb.AppendLine();
        }

        // Register middleware
        foreach (var mw in middleware)
        {
            var isOpenGeneric = mw.ClassSymbol is { IsGenericType: true, TypeParameters.Length: > 0 };
            var methodName = mw.Lifetime == "Singleton" ? "AddSingleton" : "AddScoped";

            if (isOpenGeneric)
            {
                // Open generic registration
                var interfaceName = GetMiddlewareInterfaceName(mw.MiddlewareType);
                var typeParamCount = mw.MiddlewareType == "Request" || mw.MiddlewareType == "Stream" ? 2 : 1;
                var typeParams = new string(Enumerable.Repeat(',', typeParamCount - 1).ToArray());

                var classTypeName = GetOpenGenericTypeName(mw.ClassSymbol);
                sb.AppendLine(
                    $"         builder.Services.{methodName}(typeof({interfaceName}<{typeParams}>), typeof({classTypeName}<{typeParams}>));");
            }
            else
            {
                // Closed generic or non-generic registration
                var interfaceName = GetMiddlewareInterfaceName(mw.MiddlewareType);
                var classTypeFull = GetFullTypeName(mw.ClassSymbol);

                if (mw.MiddlewareType is "Request" or "Stream")
                {
                    var requestTypeFull = GetFullTypeName(mw.RequestType);
                    var resultTypeFull = GetFullTypeName(mw.ResultType);
                    sb.AppendLine(
                        $"  builder.Services.{methodName}<{interfaceName}<{requestTypeFull}, {resultTypeFull}>, {classTypeFull}>();");
                }
                else
                {
                    var requestTypeFull = GetFullTypeName(mw.RequestType);
                    sb.AppendLine(
                        $"            builder.Services.{methodName}<{interfaceName}<{requestTypeFull}>, {classTypeFull}>();");
                }
            }
        }

        if ((uniqueHandlers.Count > 0 || middleware.Count > 0) && (hasRequestHandlers || hasStreamHandlers))
            sb.AppendLine();

        // Register executors - use fully qualified type names
        var executorNamespace = namespaceName is not null ? $"{namespaceName}." : "";

        if (hasRequestHandlers)
            sb.AppendLine(
                $"    builder.Services.AddSingleton<global::Shiny.Mediator.Infrastructure.IRequestExecutor, global::{executorNamespace}{executorClassName}>();");

        if (hasStreamHandlers)
            sb.AppendLine(
                $"   builder.Services.AddSingleton<global::Shiny.Mediator.Infrastructure.IStreamRequestExecutor, global::{executorNamespace}{streamExecutorClassName}>();");

        sb.AppendLine("        });");
        sb.AppendLine("    }");
        sb.AppendLine("}");

        return sb.ToString();
    }


    static string GetMiddlewareInterfaceName(string middlewareType) => middlewareType switch
    {
        "Request" => "global::Shiny.Mediator.IRequestMiddleware",
        "Stream" => "global::Shiny.Mediator.IStreamRequestMiddleware",
        "Command" => "global::Shiny.Mediator.ICommandMiddleware",
        "Event" => "global::Shiny.Mediator.IEventMiddleware",
        _ => throw new InvalidOperationException($"Unknown middleware type: {middlewareType}")
    };


    static string GetOpenGenericTypeName(INamedTypeSymbol typeSymbol)
    {
        var namespaceName = typeSymbol.ContainingNamespace?.ToDisplayString();
        var typeName = typeSymbol.Name;

        if (string.IsNullOrEmpty(namespaceName) || namespaceName == "<global namespace>")
            return $"global::{typeName}";

        return $"global::{namespaceName}.{typeName}";
    }


    static string GetFullTypeName(ITypeSymbol? typeSymbol)
    {
        if (typeSymbol == null)
            return String.Empty;

        return typeSymbol.ToDisplayString(
            SymbolDisplayFormat.FullyQualifiedFormat.WithGlobalNamespaceStyle(
                SymbolDisplayGlobalNamespaceStyle.Included));
    }


    record struct HandlerInfo(
        INamedTypeSymbol ClassSymbol,
        string HandlerType,
        ITypeSymbol RequestType,
        ITypeSymbol? ResultType,
        string Lifetime
    );

    record struct MiddlewareInfo(
        INamedTypeSymbol ClassSymbol,
        string MiddlewareType,
        ITypeSymbol RequestType,
        ITypeSymbol? ResultType,
        string Lifetime
    );
}