using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Shiny.Mediator.SourceGenerators;


[Generator(LanguageNames.CSharp)]
public class MediatorSourceGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Register post initialization to generate attributes
        context.RegisterPostInitializationOutput(ctx => ctx.AddSource(
            "MediatorAttributes.g.cs",
            SourceText.From(
                """
                // <auto-generated>
                // Code generated by Shiny Mediator Source Generator.
                // Changes may cause incorrect behavior and will be lost if the code is
                // regenerated.
                // </auto-generated>
                #nullable disable
                
                $GENCODEATTRIBUTE$
                [global::System.AttributeUsage(global::System.AttributeTargets.Class, AllowMultiple = false)]
                internal sealed class SingletonMediatorMiddlewareAttribute : global::System.Attribute
                {
                }
                
                $GENCODEATTRIBUTE$
                [global::System.AttributeUsage(global::System.AttributeTargets.Class, AllowMultiple = false)]
                internal sealed class ScopedMediatorMiddlewareAttribute : global::System.Attribute
                {
                }
                
                $GENCODEATTRIBUTE$
                [global::System.AttributeUsage(global::System.AttributeTargets.Class, AllowMultiple = false)]
                internal sealed class SingletonMediatorHandlerAttribute : global::System.Attribute
                {
                }
                
                $GENCODEATTRIBUTE$
                [global::System.AttributeUsage(global::System.AttributeTargets.Class, AllowMultiple = false)]
                internal sealed class ScopedMediatorHandlerAttribute : global::System.Attribute
                {
                }
                """.Replace("$GENCODEATTRIBUTE$", Constants.GeneratedCodeAttributeString),
                Encoding.UTF8
            )
        ));

        // Find all classes with handler attributes
        var handlerClasses = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (s, _) => IsCandidateClass(s),
                transform: static (ctx, _) => GetHandlerInfo(ctx))
            .Where(static m => m is not null);

        // Find all classes with middleware attributes
        var middlewareClasses = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (s, _) => IsCandidateClass(s),
                transform: static (ctx, _) => GetMiddlewareInfo(ctx))
            .Where(static m => m is not null);

        // Combine with compilation and generate output
        var handlersAndMiddleware = handlerClasses.Collect()
            .Combine(middlewareClasses.Collect());
        
        var combined = context.CompilationProvider.Combine(handlersAndMiddleware);

        context.RegisterSourceOutput(combined, static (spc, source) => 
            Execute(source.Left, source.Right.Left, source.Right.Right, spc));
    }

    static bool IsCandidateClass(SyntaxNode node)
    {
        return node is ClassDeclarationSyntax classDecl 
            && classDecl.AttributeLists.Count > 0;
    }

    static HandlerInfo? GetHandlerInfo(GeneratorSyntaxContext context)
    {
        var classDecl = (ClassDeclarationSyntax)context.Node;
        var symbol = context.SemanticModel.GetDeclaredSymbol(classDecl);
        
        if (symbol is not INamedTypeSymbol classSymbol)
            return null;

        // Check for SingletonMediatorHandler or ScopedMediatorHandler attribute
        var singletonAttr = classSymbol.GetAttributes()
            .FirstOrDefault(a => a.AttributeClass?.Name == "SingletonMediatorHandlerAttribute");
        var scopedAttr = classSymbol.GetAttributes()
            .FirstOrDefault(a => a.AttributeClass?.Name == "ScopedMediatorHandlerAttribute");

        if (singletonAttr is null && scopedAttr is null)
            return null;

        var lifetime = singletonAttr is not null ? "Singleton" : "Scoped";

        // Check if implements IRequestHandler<TRequest, TResult>
        foreach (var iface in classSymbol.AllInterfaces)
        {
            if (iface.Name == "IRequestHandler" && iface.TypeArguments.Length == 2)
            {
                return new HandlerInfo(
                    ClassSymbol: classSymbol,
                    HandlerType: "Request",
                    RequestType: iface.TypeArguments[0],
                    ResultType: iface.TypeArguments[1],
                    Lifetime: lifetime
                );
            }

            if (iface.Name == "IStreamRequestHandler" && iface.TypeArguments.Length == 2)
            {
                return new HandlerInfo(
                    ClassSymbol: classSymbol,
                    HandlerType: "Stream",
                    RequestType: iface.TypeArguments[0],
                    ResultType: iface.TypeArguments[1],
                    Lifetime: lifetime
                );
            }
            
            // ICommandHandler and IEventHandler - just register with DI, no executors
            if (iface.Name == "ICommandHandler" && iface.TypeArguments.Length == 1)
            {
                return new HandlerInfo(
                    ClassSymbol: classSymbol,
                    HandlerType: "Command",
                    RequestType: iface.TypeArguments[0],
                    ResultType: null,
                    Lifetime: lifetime
                );
            }
            
            if (iface.Name == "IEventHandler" && iface.TypeArguments.Length == 1)
            {
                return new HandlerInfo(
                    ClassSymbol: classSymbol,
                    HandlerType: "Event",
                    RequestType: iface.TypeArguments[0],
                    ResultType: null,
                    Lifetime: lifetime
                );
            }
        }

        return null;
    }

    static MiddlewareInfo? GetMiddlewareInfo(GeneratorSyntaxContext context)
    {
        var classDecl = (ClassDeclarationSyntax)context.Node;
        var symbol = context.SemanticModel.GetDeclaredSymbol(classDecl);
        
        if (symbol is not INamedTypeSymbol classSymbol)
            return null;

        // Check for SingletonMediatorMiddleware or ScopedMediatorMiddleware attribute
        var singletonAttr = classSymbol.GetAttributes()
            .FirstOrDefault(a => a.AttributeClass?.Name == "SingletonMediatorMiddlewareAttribute");
        var scopedAttr = classSymbol.GetAttributes()
            .FirstOrDefault(a => a.AttributeClass?.Name == "ScopedMediatorMiddlewareAttribute");

        if (singletonAttr is null && scopedAttr is null)
            return null;

        var lifetime = singletonAttr is not null ? "Singleton" : "Scoped";

        // Check if implements IRequestMiddleware<TRequest, TResult>
        foreach (var iface in classSymbol.AllInterfaces)
        {
            if (iface.Name == "IRequestMiddleware" && iface.TypeArguments.Length == 2)
            {
                return new MiddlewareInfo(
                    ClassSymbol: classSymbol,
                    MiddlewareType: "Request",
                    RequestType: iface.TypeArguments[0],
                    ResultType: iface.TypeArguments[1],
                    Lifetime: lifetime
                );
            }

            if (iface.Name == "IStreamRequestMiddleware" && iface.TypeArguments.Length == 2)
            {
                return new MiddlewareInfo(
                    ClassSymbol: classSymbol,
                    MiddlewareType: "Stream",
                    RequestType: iface.TypeArguments[0],
                    ResultType: iface.TypeArguments[1],
                    Lifetime: lifetime
                );
            }
            
            // ICommandMiddleware and IEventMiddleware - just register with DI, no executors
            if (iface.Name == "ICommandMiddleware" && iface.TypeArguments.Length == 1)
            {
                return new MiddlewareInfo(
                    ClassSymbol: classSymbol,
                    MiddlewareType: "Command",
                    RequestType: iface.TypeArguments[0],
                    ResultType: null,
                    Lifetime: lifetime
                );
            }
            
            if (iface.Name == "IEventMiddleware" && iface.TypeArguments.Length == 1)
            {
                return new MiddlewareInfo(
                    ClassSymbol: classSymbol,
                    MiddlewareType: "Event",
                    RequestType: iface.TypeArguments[0],
                    ResultType: null,
                    Lifetime: lifetime
                );
            }
        }

        return null;
    }

    static void Execute(Compilation compilation, ImmutableArray<HandlerInfo?> handlers, ImmutableArray<MiddlewareInfo?> middleware, SourceProductionContext context)
    {
        if (handlers.IsDefaultOrEmpty && middleware.IsDefaultOrEmpty)
            return;

        var validHandlers = handlers.Where(h => h is not null).Select(h => h!.Value).ToList();
        var validMiddleware = middleware.Where(m => m is not null).Select(m => m!.Value).ToList();
        
        if (validHandlers.Count == 0 && validMiddleware.Count == 0)
            return;

        var requestHandlers = validHandlers.Where(h => h.HandlerType == "Request").ToList();
        var streamHandlers = validHandlers.Where(h => h.HandlerType == "Stream").ToList();

        var assemblyName = compilation.AssemblyName?.Replace(".", "") ?? "Generated";

        // Generate RequestExecutor
        if (requestHandlers.Count > 0)
        {
            var requestExecutorCode = GenerateRequestExecutor(requestHandlers, assemblyName);
            context.AddSource($"{assemblyName}_RequestExecutor.g.cs", SourceText.From(requestExecutorCode, Encoding.UTF8));
        }

        // Generate StreamRequestExecutor
        if (streamHandlers.Count > 0)
        {
            var streamExecutorCode = GenerateStreamRequestExecutor(streamHandlers, assemblyName);
            context.AddSource($"{assemblyName}_StreamRequestExecutor.g.cs", SourceText.From(streamExecutorCode, Encoding.UTF8));
        }

        // Generate extension method
        var extensionCode = GenerateExtensionMethod(validHandlers, validMiddleware, assemblyName, requestHandlers.Count > 0, streamHandlers.Count > 0);
        context.AddSource($"{assemblyName}_Extensions.g.cs", SourceText.From(extensionCode, Encoding.UTF8));
    }

    static string GenerateRequestExecutor(List<HandlerInfo> handlers, string assemblyName)
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated>");
        sb.AppendLine("// Code generated by Shiny Mediator Source Generator.");
        sb.AppendLine("// </auto-generated>");
        sb.AppendLine("#nullable disable");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Threading;");
        sb.AppendLine("using System.Threading.Tasks;");
        sb.AppendLine();
        sb.AppendLine($"namespace {assemblyName};");
        sb.AppendLine();
        sb.AppendLine(Constants.GeneratedCodeAttributeString);
        sb.AppendLine($"internal class {assemblyName}RequestExecutor : global::Shiny.Mediator.Infrastructure.RequestExecutor");
        sb.AppendLine("{");
        
        // Request method
        sb.AppendLine("    public override async global::System.Threading.Tasks.Task<TResult> Request<TResult>(");
        sb.AppendLine("        global::Shiny.Mediator.IMediatorContext context,");
        sb.AppendLine("        global::Shiny.Mediator.IRequest<TResult> request,");
        sb.AppendLine("        global::System.Threading.CancellationToken cancellationToken)");
        sb.AppendLine("    {");
        
        for (int i = 0; i < handlers.Count; i++)
        {
            var handler = handlers[i];
            var requestTypeFull = GetFullTypeName(handler.RequestType);
            var resultTypeFull = GetFullTypeName(handler.ResultType);
            
            sb.AppendLine($"        if (request is {requestTypeFull} p{i})");
            sb.AppendLine("        {");
            sb.AppendLine($"            object result = await this.Execute<{requestTypeFull}, {resultTypeFull}>(p{i}, context, cancellationToken);");
            sb.AppendLine("            return (TResult)result;");
            sb.AppendLine("        }");
            sb.AppendLine();
        }
        
        sb.AppendLine("        throw new global::System.InvalidOperationException(\"Unknown request type\");");
        sb.AppendLine("    }");
        sb.AppendLine();
        
        // CanHandle method
        sb.AppendLine("    public override bool CanHandle<TResult>(global::Shiny.Mediator.IRequest<TResult> request)");
        sb.AppendLine("    {");
        
        for (int i = 0; i < handlers.Count; i++)
        {
            var handler = handlers[i];
            var requestTypeFull = GetFullTypeName(handler.RequestType);
            sb.AppendLine($"        if (request is {requestTypeFull})");
            sb.AppendLine("            return true;");
            sb.AppendLine();
        }
        
        sb.AppendLine("        return false;");
        sb.AppendLine("    }");
        sb.AppendLine("}");
        
        return sb.ToString();
    }

    static string GenerateStreamRequestExecutor(List<HandlerInfo> handlers, string assemblyName)
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated>");
        sb.AppendLine("// Code generated by Shiny Mediator Source Generator.");
        sb.AppendLine("// </auto-generated>");
        sb.AppendLine("#nullable disable");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using System.Threading;");
        sb.AppendLine();
        sb.AppendLine($"namespace {assemblyName};");
        sb.AppendLine();
        sb.AppendLine(Constants.GeneratedCodeAttributeString);
        sb.AppendLine($"internal class {assemblyName}StreamRequestExecutor : global::Shiny.Mediator.Infrastructure.StreamRequestExecutor");
        sb.AppendLine("{");
        
        // Request method
        sb.AppendLine("    public override global::System.Collections.Generic.IAsyncEnumerable<TResult> Request<TResult>(");
        sb.AppendLine("        global::Shiny.Mediator.IMediatorContext context,");
        sb.AppendLine("        global::Shiny.Mediator.IStreamRequest<TResult> request,");
        sb.AppendLine("        global::System.Threading.CancellationToken cancellationToken)");
        sb.AppendLine("    {");
        
        for (int i = 0; i < handlers.Count; i++)
        {
            var handler = handlers[i];
            var requestTypeFull = GetFullTypeName(handler.RequestType);
            var resultTypeFull = GetFullTypeName(handler.ResultType);
            
            sb.AppendLine($"        if (request is {requestTypeFull} p{i})");
            sb.AppendLine("        {");
            sb.AppendLine($"            var handle = this.Execute<{requestTypeFull}, {resultTypeFull}>(context, p{i}, cancellationToken);");
            sb.AppendLine("            return (global::System.Collections.Generic.IAsyncEnumerable<TResult>)handle;");
            sb.AppendLine("        }");
            sb.AppendLine();
        }
        
        sb.AppendLine("        throw new global::System.InvalidOperationException(\"Unknown request type\");");
        sb.AppendLine("    }");
        sb.AppendLine();
        
        // CanRequest method
        sb.AppendLine("    public override bool CanRequest<TResult>(global::Shiny.Mediator.IStreamRequest<TResult> request)");
        sb.AppendLine("    {");
        
        for (int i = 0; i < handlers.Count; i++)
        {
            var handler = handlers[i];
            var requestTypeFull = GetFullTypeName(handler.RequestType);
            sb.AppendLine($"        if (request is {requestTypeFull})");
            sb.AppendLine("            return true;");
            sb.AppendLine();
        }
        
        sb.AppendLine("        return false;");
        sb.AppendLine("    }");
        sb.AppendLine("}");
        
        return sb.ToString();
    }

    static string GenerateExtensionMethod(List<HandlerInfo> handlers, List<MiddlewareInfo> middleware, string assemblyName, bool hasRequestHandlers, bool hasStreamHandlers)
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated>");
        sb.AppendLine("// Code generated by Shiny Mediator Source Generator.");
        sb.AppendLine("// </auto-generated>");
        sb.AppendLine("#nullable disable");
        sb.AppendLine();
        sb.AppendLine("using Microsoft.Extensions.DependencyInjection;");
        sb.AppendLine("using Shiny.Mediator;");
        sb.AppendLine();
        sb.AppendLine($"namespace {assemblyName};");
        sb.AppendLine();
        sb.AppendLine(Constants.GeneratedCodeAttributeString);
        sb.AppendLine($"public static class __ShinyMediatorSourceGenExtensions");
        sb.AppendLine("{");
        sb.AppendLine($"    public static global::Microsoft.Extensions.DependencyInjection.IServiceCollection AddDiscoveredMediatorHandlersFrom{assemblyName}(this global::Microsoft.Extensions.DependencyInjection.IServiceCollection services)");
        sb.AppendLine("    {");
        
        // Register handlers
        foreach (var handler in handlers)
        {
            var handlerTypeFull = GetFullTypeName(handler.ClassSymbol);
            var methodName = handler.Lifetime == "Singleton" ? "AddSingletonAsImplementedInterfaces" : "AddScopedAsImplementedInterfaces";
            sb.AppendLine($"        services.{methodName}<{handlerTypeFull}>();");
        }
        
        if (handlers.Count > 0 && middleware.Count > 0)
        {
            sb.AppendLine();
        }
        
        // Register middleware
        foreach (var mw in middleware)
        {
            var isOpenGeneric = mw.ClassSymbol.IsGenericType && mw.ClassSymbol.TypeParameters.Length > 0;
            var methodName = mw.Lifetime == "Singleton" ? "AddSingleton" : "AddScoped";
            
            if (isOpenGeneric)
            {
                // Open generic registration
                var interfaceName = GetMiddlewareInterfaceName(mw.MiddlewareType);
                var typeParamCount = mw.MiddlewareType == "Request" || mw.MiddlewareType == "Stream" ? 2 : 1;
                var typeParams = new string(Enumerable.Repeat(',', typeParamCount - 1).ToArray());
                
                var classTypeName = GetOpenGenericTypeName(mw.ClassSymbol);
                sb.AppendLine($"        services.{methodName}(typeof({interfaceName}<{typeParams}>), typeof({classTypeName}<{typeParams}>));");
            }
            else
            {
                // Closed generic or non-generic registration
                var interfaceName = GetMiddlewareInterfaceName(mw.MiddlewareType);
                var classTypeFull = GetFullTypeName(mw.ClassSymbol);
                
                if (mw.MiddlewareType == "Request" || mw.MiddlewareType == "Stream")
                {
                    var requestTypeFull = GetFullTypeName(mw.RequestType);
                    var resultTypeFull = GetFullTypeName(mw.ResultType);
                    sb.AppendLine($"        services.{methodName}<{interfaceName}<{requestTypeFull}, {resultTypeFull}>, {classTypeFull}>();");
                }
                else
                {
                    var requestTypeFull = GetFullTypeName(mw.RequestType);
                    sb.AppendLine($"        services.{methodName}<{interfaceName}<{requestTypeFull}>, {classTypeFull}>();");
                }
            }
        }
        
        if ((handlers.Count > 0 || middleware.Count > 0) && (hasRequestHandlers || hasStreamHandlers))
        {
            sb.AppendLine();
        }
        
        // Register executors
        if (hasRequestHandlers)
        {
            sb.AppendLine($"        services.AddSingleton<global::Shiny.Mediator.Infrastructure.IRequestExecutor, {assemblyName}.{assemblyName}RequestExecutor>();");
        }
        
        if (hasStreamHandlers)
        {
            sb.AppendLine($"        services.AddSingleton<global::Shiny.Mediator.Infrastructure.IStreamRequestExecutor, {assemblyName}.{assemblyName}StreamRequestExecutor>();");
        }
        
        sb.AppendLine();
        sb.AppendLine("        return services;");
        sb.AppendLine("    }");
        sb.AppendLine("}");
        
        return sb.ToString();
    }

    static string GetMiddlewareInterfaceName(string middlewareType)
    {
        return middlewareType switch
        {
            "Request" => "global::Shiny.Mediator.IRequestMiddleware",
            "Stream" => "global::Shiny.Mediator.IStreamRequestMiddleware",
            "Command" => "global::Shiny.Mediator.ICommandMiddleware",
            "Event" => "global::Shiny.Mediator.IEventMiddleware",
            _ => throw new InvalidOperationException($"Unknown middleware type: {middlewareType}")
        };
    }

    static string GetOpenGenericTypeName(INamedTypeSymbol typeSymbol)
    {
        var namespaceName = typeSymbol.ContainingNamespace?.ToDisplayString();
        var typeName = typeSymbol.Name;
        
        if (string.IsNullOrEmpty(namespaceName) || namespaceName == "<global namespace>")
        {
            return $"global::{typeName}";
        }
        
        return $"global::{namespaceName}.{typeName}";
    }

    static string GetFullTypeName(ITypeSymbol? typeSymbol)
    {
        if (typeSymbol is null)
            return string.Empty;
        
        return typeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat.WithGlobalNamespaceStyle(SymbolDisplayGlobalNamespaceStyle.Included));
    }

    record struct HandlerInfo(
        INamedTypeSymbol ClassSymbol,
        string HandlerType,
        ITypeSymbol RequestType,
        ITypeSymbol? ResultType,
        string Lifetime
    );

    record struct MiddlewareInfo(
        INamedTypeSymbol ClassSymbol,
        string MiddlewareType,
        ITypeSymbol RequestType,
        ITypeSymbol? ResultType,
        string Lifetime
    );
}
/*
I want to add middleware registration, but slightly different from handlers

GIVEN middleware classes marked with [SingletonMediatorMiddleware] or [ScopedMediatorMiddleware] and implementing
ICommandMiddleware, IEventMiddleware, IRequestMiddleware, or IStreamRequestMiddleware, register them with the same dependency injection file, BUT the following:

NOTE: if the middleware class uses generics, you need to register them OPEN
public class MyCommandMiddleware<TCommand> : AbstractValidationCommandMiddleware<TCommand> where TCommand : ICommand

would register as 
services.AddScoped(typeof(ICommandMiddleware<>), typeof(MyCommandMiddleware<>));

Request handlers with generics (Use AddSingleton for [SingletonMediatorMiddleware])
services.AddScoped(typeof(IRequestMiddleware<,>), typeof(MyRequestMiddleware<,>));

OR straight up closed (Use AddSingleton for [SingletonMediatorMiddleware])
services.AddScoped<IRequestHandler<MyRequest, MyResponse>, MyRequestHandler>();

same for event middleware and stream request middleware
 */