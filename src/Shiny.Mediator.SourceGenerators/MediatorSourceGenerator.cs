using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Shiny.Mediator.SourceGenerators;


[Generator(LanguageNames.CSharp)]
public class MediatorSourceGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Register post initialization to generate attributes
        context.RegisterPostInitializationOutput(ctx => ctx.AddSource(
            "MediatorAttributes.g.cs",
            SourceText.From(
                """
                // <auto-generated>
                // Code generated by Shiny Mediator Source Generator.
                // Changes may cause incorrect behavior and will be lost if the code is
                // regenerated.
                // </auto-generated>
                #nullable disable
                
                $GENCODEATTRIBUTE$
                [global::System.AttributeUsage(global::System.AttributeTargets.Class, AllowMultiple = false)]
                internal sealed class SingletonHandlerAttribute : global::System.Attribute
                {
                }
                
                $GENCODEATTRIBUTE$
                [global::System.AttributeUsage(global::System.AttributeTargets.Class, AllowMultiple = false)]
                internal sealed class ScopedHandlerAttribute : global::System.Attribute
                {
                }
                """.Replace("$GENCODEATTRIBUTE$", Constants.GeneratedCodeAttributeString),
                Encoding.UTF8
            )
        ));

        // Create provider for classes with handler attributes
        var classesProvider = context.SyntaxProvider
            .CreateSyntaxProvider<INamedTypeSymbol?>(
                predicate: static (s, _) => IsCandidateNode(s),
                transform: static (ctx, _) => GetSemanticTargetForGeneration(ctx))
            .Where(static m => m is not null)
            .Collect();

        // Create provider for MSBuild properties
        var configProvider = context.AnalyzerConfigOptionsProvider;

        // Combine providers
        var combined = classesProvider
            .Combine(context.CompilationProvider)
            .Combine(configProvider);

        // Register source output
        context.RegisterSourceOutput(combined, static (spc, source) => Execute(spc, source));
    }

    static bool IsCandidateNode(SyntaxNode node)
    {
        return node is ClassDeclarationSyntax classDeclaration && 
               classDeclaration.AttributeLists.Count > 0;
    }

    static INamedTypeSymbol? GetSemanticTargetForGeneration(GeneratorSyntaxContext context)
    {
        var classDeclaration = (ClassDeclarationSyntax)context.Node;
        var symbol = context.SemanticModel.GetDeclaredSymbol(classDeclaration) as INamedTypeSymbol;
        
        if (symbol == null)
            return null;

        // Skip Shiny.Mediator assembly classes
        if (symbol.ContainingAssembly.Name.StartsWith("Shiny.Mediator", StringComparison.CurrentCultureIgnoreCase))
            return null;
        
        // Check if class has handler attributes
        var hasAttribute = HasAttribute(symbol, "SingletonHandlerAttribute") ||
                          HasAttribute(symbol, "ScopedHandlerAttribute");
        
        return hasAttribute ? symbol : null;
    }

    static bool HasAttribute(INamedTypeSymbol symbol, string attributeName) => symbol
        .GetAttributes()
        .Any(x => 
            x.AttributeClass?.Name == attributeName ||
            x.AttributeClass?.ToDisplayString().EndsWith(attributeName) == true
        );

    static string? FindCommonNamespace(List<string> namespaces)
    {
        if (namespaces.Count == 0)
            return null;
            
        if (namespaces.Count == 1)
            return namespaces[0];
            
        // Split namespaces into parts
        var namespaceParts = namespaces
            .Select(ns => ns.Split('.'))
            .ToList();
            
        // Find common prefix
        var minLength = namespaceParts.Min(parts => parts.Length);
        var commonParts = new List<string>();
        
        for (int i = 0; i < minLength; i++)
        {
            var part = namespaceParts[0][i];
            if (namespaceParts.All(parts => parts[i] == part))
            {
                commonParts.Add(part);
            }
            else
            {
                break;
            }
        }
        
        return commonParts.Count > 0 ? string.Join(".", commonParts) : null;
    }

    static void Execute(SourceProductionContext context, ((ImmutableArray<INamedTypeSymbol?> Classes, Compilation Compilation) Left, Microsoft.CodeAnalysis.Diagnostics.AnalyzerConfigOptionsProvider ConfigOptions) input)
    {
        var ((classes, compilation), configOptions) = input;

        // Check if source generation is disabled
        var globalOptions = configOptions.GlobalOptions;
        if (globalOptions.TryGetValue("build_property.ShinyMediatorDisableSourceGen", out var skipValue) &&
            skipValue.Equals("true", StringComparison.InvariantCultureIgnoreCase))
            return;

        // Filter out null values and deduplicate
        var validClasses = classes
            .Where(c => c is not null)
            .GroupBy(x => x!.ToDisplayString())
            .Select(x => x.First()!)
            .ToList();

        if (!validClasses.Any())
            return;

        // Get namespace and assembly name
        globalOptions.TryGetValue("build_property.RootNamespace", out var nameSpace);
        
        // If RootNamespace is not provided, try to infer from handler namespaces
        if (string.IsNullOrEmpty(nameSpace))
        {
            // Try to find a common namespace from the handlers
            var namespaces = validClasses
                .Select(c => c.ContainingNamespace?.ToDisplayString())
                .Where(ns => !string.IsNullOrEmpty(ns))
                .Distinct()
                .ToList();
            
            if (namespaces.Count == 1)
            {
                // If all handlers are in the same namespace, use that
                nameSpace = namespaces[0];
            }
            else if (namespaces.Count > 1)
            {
                // Find the common root namespace
                nameSpace = FindCommonNamespace(namespaces);
            }
        }
        
        // Final fallback to assembly name
        nameSpace ??= compilation.AssemblyName;
        
        var assName = compilation.AssemblyName?.Replace(".", "_");
        
        var sb = new StringBuilder();
        sb
            .AppendLine("using Shiny.Mediator;")
            .AppendLine()
            .AppendLine($"namespace {nameSpace};")
            .AppendLine()
            .AppendLine(Constants.GeneratedCodeAttributeString)
            .AppendLine("public static class __ShinyMediatorSourceGenExtensions {")
            .AppendLine($"\tpublic static global::Microsoft.Extensions.DependencyInjection.IServiceCollection AddDiscoveredMediatorHandlersFrom{assName}(this global::Microsoft.Extensions.DependencyInjection.IServiceCollection services)")
            .AppendLine("\t{");

        foreach (var clazz in validClasses)
        {
            var cls = clazz.ToDisplayString();
            if (HasAttribute(clazz, "ScopedHandlerAttribute") || HasAttribute(clazz, "ScopedMiddlewareAttribute"))
                sb.AppendLine($"\t\tservices.AddScopedAsImplementedInterfaces<{cls}>();");
            else
                sb.AppendLine($"\t\tservices.AddSingletonAsImplementedInterfaces<{cls}>();");
        }

        sb
            .AppendLine("\t\treturn services;")
            .AppendLine("\t}")
            .AppendLine("}");

        context.AddSource("__MediatorHandlersRegistration.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
    }
}

/*
Given
   
   [MediatorHandler]
   public class MyRequestHandler : IRequestHandler<MyRequestHandler, MyResponse>
   {
   public Task<MyResponse> Handle(MyRequest request, CancellationToken cancellationToken)
   {
   // Handle the request and return a response
   var response = new MyResponse
   {
   Message = $"Hello, {request.Name}!"
   };
   return Task.FromResult(response);
   }
   }
   
   
   [MediatorMiddleware(1)]
   public class MyRequestMiddleware : IRequestMiddleware<MyResponse, MyResponse>
   {
   public string Name { get; set; }
   }
   
   [MediatorMiddleware(2)]
   public class GenericRequestMiddleware<TRequest, TResponse> : IRequestMiddleware<MyResponse, TResponse>
   {
   public string Name { get; set; }
   }
   
   
   
   GENERATES:
   
   public class RequestExecutor : IRequestExecutor
   {
   
       public Task<MyResponse> Execute(MyRequest request, CancellationToken cancellationToken = default)
       {
           var middleware1 = new MyRequestMiddleware { Name = "MyRequestMiddleware" };
           var middleware2 = new GenericRequestMiddleware<MyRequest, MyResponse> { Name = "GenericRequestMiddleware" };
           var handler = new MyRequestHandler();
           
           Func<Task<MyResponse>> handlerFunc = () => handler.Handle(request, cancellationToken);
           
           Func<Task<MyResponse>> pipeline = () => middleware2.Invoke(() => middleware1.Invoke(handlerFunc), request, cancellationToken);
           
           return pipeline();
       }
   }
   
 */