using System;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Linq;
using System.Text;

namespace Shiny.Mediator.SourceGenerators;


[Generator(LanguageNames.CSharp)]
public class JsonConverterSourceGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(x =>
        {
            x.AddSource(
                "SourceGenerateJsonConverterAttribute.g.cs",
                """
                // <auto-generated/>
                using System;

                [AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct, Inherited = false, AllowMultiple = false)]
                internal sealed class SourceGenerateJsonConverterAttribute : Attribute;
                """
            );
        });

        // Find all types marked with SourceGenerateJsonConverter attribute
        var typesToGenerate = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                "SourceGenerateJsonConverterAttribute",
                predicate: static (node, _) => node is TypeDeclarationSyntax,
                transform: static (context, _) => GetTypeInfo(context)
            )
            .Where(static x => x is not null);

        context.RegisterSourceOutput(typesToGenerate.Collect(), static (context, types) =>
        {
            foreach (var typeInfo in types)
            {
                if (typeInfo != null)
                {
                    // Check if class is partial (structs don't need to be partial)
                    if (typeInfo.IsClass && !typeInfo.IsPartial)
                    {
                        var diagnostic = Diagnostic.Create(
                            new DiagnosticDescriptor(
                                "SJSG001",
                                "Class must be partial",
                                "Class '{0}' marked with SourceGenerateJsonConverter must be declared as partial",
                                "JsonSourceGenerator",
                                DiagnosticSeverity.Error,
                                true
                            ),
                            typeInfo.Location,
                            typeInfo.Name
                        );
                        
                        context.ReportDiagnostic(diagnostic);
                    }
                    else
                    {
                        GenerateJsonConverter(context, typeInfo);
                        GeneratePartialTypeWithAttribute(context, typeInfo);
                    }
                }
            }
        });
    }

    private static TypeInfo? GetTypeInfo(GeneratorAttributeSyntaxContext context)
    {
        if (context.TargetNode is not TypeDeclarationSyntax typeDeclaration)
            return null;

        var typeSymbol = context.SemanticModel.GetDeclaredSymbol(typeDeclaration);
        if (typeSymbol is null)
            return null;

        var properties = typeSymbol
            .GetMembers()
            .OfType<IPropertySymbol>()
            .Where(x => 
                x.DeclaredAccessibility == Accessibility.Public && 
                x.GetMethod != null && 
                x.SetMethod != null
            )
            .Select(x => new PropertyInfo(
                x.Name,
                x.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat),
                x.Type.CanBeReferencedByName,
                IsNullableType(x.Type),
                GetJsonPropertyName(x),
                x.Type
            ))
            .ToArray();

        // Check if the type is partial
        var isPartial = typeDeclaration.Modifiers.Any(m => m.IsKind(SyntaxKind.PartialKeyword));
        
        // Determine the type kind (class, struct, record, record struct)
        var typeKind = GetTypeKind(typeDeclaration);
        
        return new TypeInfo(
            typeSymbol.Name,
            typeSymbol.ContainingNamespace?.ToDisplayString() ?? "",
            typeDeclaration.IsKind(SyntaxKind.ClassDeclaration) || typeDeclaration.IsKind(SyntaxKind.RecordDeclaration),
            isPartial,
            properties,
            typeDeclaration.GetLocation(),
            typeKind
        );
    }

    private static string GetTypeKind(TypeDeclarationSyntax typeDeclaration)
    {
        if (typeDeclaration.IsKind(SyntaxKind.RecordStructDeclaration))
            return "record struct";
        if (typeDeclaration.IsKind(SyntaxKind.RecordDeclaration))
            return "record";
        if (typeDeclaration.IsKind(SyntaxKind.ClassDeclaration))
            return "class";
        if (typeDeclaration.IsKind(SyntaxKind.StructDeclaration))
            return "struct";
        
        return "class"; // fallback
    }

    private static bool IsNullableType(ITypeSymbol type)
    {
        // Check if it's a nullable value type (e.g., int?, DateTime?)
        if (type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T)
            return true;

        // For reference types, they are inherently nullable in C#
        // Even without explicit nullable annotations, strings and other reference types can be null
        if (type.IsReferenceType)
        {
            return true; // All reference types can be null
        }

        return false;
    }


    public static void GenerateJsonConverter(SourceProductionContext context, INamedTypeSymbol typeSymbol)
    {
        // Get the syntax node for the type symbol to check if it's partial
        var syntaxReferences = typeSymbol.DeclaringSyntaxReferences;
        if (!syntaxReferences.Any())
            return;

        var typeDeclaration = syntaxReferences.First().GetSyntax() as TypeDeclarationSyntax;
        if (typeDeclaration == null)
            return;

        // Extract type information
        var properties = typeSymbol
            .GetMembers()
            .OfType<IPropertySymbol>()
            .Where(x => 
                x.DeclaredAccessibility == Accessibility.Public && 
                x.GetMethod != null && 
                x.SetMethod != null
            )
            .Select(x => new PropertyInfo(
                x.Name,
                x.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat),
                x.Type.CanBeReferencedByName,
                IsNullableType(x.Type),
                GetJsonPropertyName(x),
                x.Type
            ))
            .ToArray();

        // Check if the type is partial
        var isPartial = typeDeclaration.Modifiers.Any(m => m.IsKind(SyntaxKind.PartialKeyword));
        var isClass = typeSymbol.TypeKind == TypeKind.Class;
        
        // Determine the type kind (class, struct, record, record struct)
        var typeKind = GetTypeKind(typeDeclaration);

        var typeInfo = new TypeInfo(
            typeSymbol.Name,
            typeSymbol.ContainingNamespace?.ToDisplayString() ?? "",
            isClass,
            isPartial,
            properties,
            typeDeclaration.GetLocation(),
            typeKind
        );

        // Validate that classes are partial (structs don't need to be partial)
        if (typeInfo.IsClass && !typeInfo.IsPartial)
        {
            var diagnostic = Diagnostic.Create(
                new DiagnosticDescriptor(
                    "SJSG001",
                    "Class must be partial",
                    "Class '{0}' marked with SourceGenerateJsonConverter must be declared as partial",
                    "JsonSourceGenerator",
                    DiagnosticSeverity.Error,
                    true
                ),
                typeInfo.Location,
                typeInfo.Name
            );
            context.ReportDiagnostic(diagnostic);
        }
        else
        {
            GenerateJsonConverter(context, typeInfo);
            GeneratePartialTypeWithAttribute(context, typeInfo);
        }
    }
    

    private static void GeneratePartialTypeWithAttribute(SourceProductionContext context, TypeInfo typeInfo)
    {
        var sb = new StringBuilder();
        
        sb.AppendLine("// <auto-generated>");
        sb.AppendLine("// This code was generated by Shiny.Json.SourceGenerator");
        sb.AppendLine("// </auto-generated>");
        sb.AppendLine("using System.Text.Json.Serialization;");
        sb.AppendLine();
        
        if (!String.IsNullOrEmpty(typeInfo.Namespace))
        {
            sb.AppendLine($"namespace {typeInfo.Namespace};");
            sb.AppendLine();
        }

        var typeKeyword = typeInfo.TypeKind;
        // All types need to be partial to accept the JsonConverter attribute
        
        sb.AppendLine($"[global::System.Text.Json.Serialization.JsonConverter(typeof({typeInfo.Name}JsonConverter))]");
        sb.AppendLine($"partial {typeKeyword} {typeInfo.Name}");
        sb.AppendLine("{");
        sb.AppendLine("}");

        var ns = String.Empty;
        if (!String.IsNullOrWhiteSpace(typeInfo.Namespace) && !typeInfo.Namespace.Contains("<"))
            ns = typeInfo.Namespace + ".";
        
        context.AddSource($"{ns}{typeInfo.Name}.JsonConverterAttribute.g.cs", sb.ToString());
    }
    

    private static void GenerateJsonConverter(SourceProductionContext context, TypeInfo typeInfo)
    {
        var sb = new StringBuilder();
        
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Text.Json;");
        sb.AppendLine("using System.Text.Json.Serialization;");
        sb.AppendLine();

        if (!string.IsNullOrEmpty(typeInfo.Namespace))
        {
            sb.AppendLine($"namespace {typeInfo.Namespace};");
            sb.AppendLine();
        }

        sb.AppendLine($"public sealed class {typeInfo.Name}JsonConverter : JsonConverter<{typeInfo.Name}>");
        sb.AppendLine("{");

        // Write method
        sb.AppendLine($"    public override void Write(Utf8JsonWriter writer, {typeInfo.Name} value, JsonSerializerOptions options)");
        sb.AppendLine("    {");

        // For structs, we don't need null checks on the main value
        if (typeInfo.IsClass)
        {
            sb.AppendLine("        if (value == null)");
            sb.AppendLine("        {");
            sb.AppendLine("            writer.WriteNullValue();");
            sb.AppendLine("            return;");
            sb.AppendLine("        }");
            sb.AppendLine();
        }
        
        sb.AppendLine("        writer.WriteStartObject();");
        
        foreach (var prop in typeInfo.Properties)
        {
            sb.AppendLine($"        writer.WritePropertyName(\"{prop.JsonPropertyName}\");");
            
            var writerMethod = GetWriterMethodForType(prop.TypeName, $"value.{prop.Name}", prop.IsNullable, prop.TypeSymbol);
            
            if (prop.IsNullable)
            {
                sb.AppendLine($"        if (value.{prop.Name} == null)");
                sb.AppendLine("            writer.WriteNullValue();");
                sb.AppendLine("        else");
                
                if (writerMethod != null)
                {
                    sb.AppendLine($"            {writerMethod};");
                }
                else
                {
                    sb.AppendLine($"            JsonSerializer.Serialize(writer, value.{prop.Name}, options);");
                }
            }
            else
            {
                if (writerMethod != null)
                {
                    sb.AppendLine($"        {writerMethod};");
                }
                else
                {
                    sb.AppendLine($"        JsonSerializer.Serialize(writer, value.{prop.Name}, options);");
                }
            }
        }
        
        sb.AppendLine("        writer.WriteEndObject();");
        sb.AppendLine("    }");
        sb.AppendLine();

        // Read method
        string returnType = typeInfo.IsClass ? $"{typeInfo.Name}?" : typeInfo.Name;
        sb.AppendLine($"    public override {returnType} Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)");
        sb.AppendLine("    {");
        sb.AppendLine("        if (reader.TokenType == JsonTokenType.Null)");
        if (typeInfo.IsClass)
        {
            sb.AppendLine("            return null;");
        }
        else
        {
            sb.AppendLine($"            throw new JsonException(\"Cannot deserialize null to struct {typeInfo.Name}\");");
        }
        sb.AppendLine();
        sb.AppendLine("        if (reader.TokenType != JsonTokenType.StartObject)");
        sb.AppendLine("            throw new JsonException(\"Expected StartObject token\");");
        sb.AppendLine();
        
        // For records, we need to collect values and use the constructor
        var isRecord = typeInfo.TypeKind.Contains("record");
        
        if (isRecord)
        {
            // Declare variables for each property with default values
            foreach (var prop in typeInfo.Properties)
            {
                var defaultValue = GetDefaultValue(prop.TypeName, prop.IsNullable);
                sb.AppendLine($"        {prop.TypeName} {ToCamelCase(prop.Name)} = {defaultValue};");
            }
        }
        else
        {
            sb.AppendLine($"        var result = new {typeInfo.Name}();");
        }
        
        sb.AppendLine();
        sb.AppendLine("        while (reader.Read())");
        sb.AppendLine("        {");
        sb.AppendLine("            if (reader.TokenType == JsonTokenType.EndObject)");
        sb.AppendLine("                break;");
        sb.AppendLine();
        sb.AppendLine("            if (reader.TokenType != JsonTokenType.PropertyName)");
        sb.AppendLine("                throw new JsonException(\"Expected PropertyName token\");");
        sb.AppendLine();
        sb.AppendLine("            var propertyName = reader.GetString();");
        sb.AppendLine("            reader.Read();");
        sb.AppendLine();
        sb.AppendLine("            switch (propertyName)");
        sb.AppendLine("            {");

        foreach (var prop in typeInfo.Properties)
        {
            sb.AppendLine($"                case \"{prop.JsonPropertyName}\":");
            
            var readerMethod = GetReaderMethodForType(prop.TypeName, prop.IsNullable, prop.TypeSymbol);
            var targetVariable = isRecord ? ToCamelCase(prop.Name) : $"result.{prop.Name}";
            
            sb.AppendLine("                    if (reader.TokenType != JsonTokenType.Null)");
            if (readerMethod != null)
            {
                sb.AppendLine($"                        {targetVariable} = {readerMethod};");
            }
            else
            {
                sb.AppendLine($"                        {targetVariable} = JsonSerializer.Deserialize<{prop.TypeName}>(ref reader, options);");
            }
            sb.AppendLine("                    break;");
        }

        sb.AppendLine("                default:");
        sb.AppendLine("                    reader.Skip();");
        sb.AppendLine("                    break;");
        sb.AppendLine("            }");
        sb.AppendLine("        }");
        sb.AppendLine();
        
        if (isRecord)
        {
            // Create the record using the constructor
            var constructorArgs = string.Join(", ", typeInfo.Properties.Select(p => ToCamelCase(p.Name)));
            sb.AppendLine($"        return new {typeInfo.Name}({constructorArgs});");
        }
        else
        {
            sb.AppendLine("        return result;");
        }
        
        sb.AppendLine("    }");
        sb.AppendLine("}");

        var ns = String.Empty;
        if (!String.IsNullOrWhiteSpace(typeInfo.Namespace) && !typeInfo.Namespace.Contains("<"))
            ns = typeInfo.Namespace + ".";
        
        context.AddSource($"{ns}{typeInfo.Name}JsonConverter.g.cs", sb.ToString());
    }

    static string? GetReaderMethodForType(string typeName, bool isNullable, ITypeSymbol? typeSymbol = null)
    {
        // Remove global:: prefix and nullable annotations for type matching
        var cleanTypeName = typeName.Replace("global::", "").Replace("?", "");
        
        // Check if it's an enum type
        if (typeSymbol is { TypeKind: TypeKind.Enum })
        {
            // Check if the enum has a JsonConverter attribute
            var hasJsonConverter = typeSymbol.GetAttributes()
                .Any(attr => attr.AttributeClass?.ToDisplayString().Contains("JsonConverter") == true);
            
            if (!hasJsonConverter)
            {
                // Treat enum as string by default
                var enumParseMethod = $"System.Enum.Parse<{cleanTypeName}>(reader.GetString()!)";
                if (isNullable)
                {
                    return $"({cleanTypeName}?){enumParseMethod}";
                }
                return enumParseMethod;
            }
        }
        
        var readerMethod = cleanTypeName switch
        {
            "System.Boolean" or "bool" => "reader.GetBoolean()",
            "System.String" or "string" => "reader.GetString()",
            "System.DateTime" => "reader.GetDateTime()",
            "System.DateTimeOffset" => "reader.GetDateTimeOffset()",
            "System.Single" or "float" => "reader.GetSingle()",
            "System.UInt16" or "ushort" => "reader.GetUInt16()",
            "System.UInt32" or "uint" => "reader.GetUInt32()",
            "System.UInt64" or "ulong" => "reader.GetUInt64()",
            "System.Double" or "double" => "reader.GetDouble()",
            "System.Decimal" or "decimal" => "reader.GetDecimal()",
            "System.Int16" or "short" => "reader.GetInt16()",
            "System.Int32" or "int" => "reader.GetInt32()",
            "System.Int64" or "long" => "reader.GetInt64()",
            "System.Guid" => "reader.GetGuid()",
            _ => null
        };

        // For nullable value types, we need to cast the result to nullable
        if (readerMethod != null && isNullable && !cleanTypeName.Equals("System.String", StringComparison.Ordinal) && !cleanTypeName.Equals("string", StringComparison.Ordinal))
        {
            // String is already nullable (reference type), but value types need explicit nullable casting
            return $"({cleanTypeName}?){readerMethod}";
        }

        return readerMethod;
    }

    static string? GetWriterMethodForType(string typeName, string valueExpression, bool isNullable, ITypeSymbol? typeSymbol = null)
    {
        // Remove global:: prefix and nullable annotations for type matching
        var cleanTypeName = typeName.Replace("global::", "").Replace("?", "");
        
        // Check if it's an enum type
        if (typeSymbol != null && typeSymbol.TypeKind == TypeKind.Enum)
        {
            // Check if the enum has a JsonConverter attribute
            var hasJsonConverter = typeSymbol.GetAttributes()
                .Any(attr => attr.AttributeClass?.ToDisplayString().Contains("JsonConverter") == true);
            
            if (!hasJsonConverter)
            {
                // Treat enum as string by default
                var enumExpr = isNullable ? $"{valueExpression}?.ToString()" : $"{valueExpression}.ToString()";
                return $"writer.WriteStringValue({enumExpr})";
            }
        }
        
        // For nullable value types, we need to use .Value
        var needsValue = isNullable &&
            cleanTypeName != "System.String" &&
            cleanTypeName != "string";

        var expr = needsValue ? $"{valueExpression}.Value" : valueExpression;
        
        return cleanTypeName switch
        {
            "System.Boolean" or "bool" => $"writer.WriteBooleanValue({expr})",
            "System.String" or "string" => $"writer.WriteStringValue({expr})",
            "System.DateTime" => $"writer.WriteStringValue({expr}.ToString(\"O\"))",
            "System.DateTimeOffset" => $"writer.WriteStringValue({expr}.ToString(\"O\"))",
            "System.Single" or "float" => $"writer.WriteNumberValue({expr})",
            "System.UInt16" or "ushort" => $"writer.WriteNumberValue({expr})",
            "System.UInt32" or "uint" => $"writer.WriteNumberValue({expr})",
            "System.UInt64" or "ulong" => $"writer.WriteNumberValue({expr})",
            "System.Double" or "double" => $"writer.WriteNumberValue({expr})",
            "System.Decimal" or "decimal" => $"writer.WriteNumberValue({expr})",
            "System.Int16" or "short" => $"writer.WriteNumberValue({expr})",
            "System.Int32" or "int" => $"writer.WriteNumberValue({expr})",
            "System.Int64" or "long" => $"writer.WriteNumberValue({expr})",
            "System.Guid" => $"writer.WriteStringValue({expr}.ToString())",
            _ => null
        };
    }

    record TypeInfo(
        string Name,
        string Namespace,
        bool IsClass,
        bool IsPartial,
        PropertyInfo[] Properties,
        Location Location,
        string TypeKind
    );


    record PropertyInfo(
        string Name, 
        string TypeName, 
        bool CanBeReferenced, 
        bool IsNullable,
        string JsonPropertyName,
        ITypeSymbol TypeSymbol
    );

    private static string GetJsonPropertyName(IPropertySymbol property)
    {
        // Check if the property has the JsonPropertyName attribute
        var jsonPropertyNameAttribute = property.GetAttributes()
            .FirstOrDefault(attr => attr.AttributeClass?.ToDisplayString() == "System.Text.Json.Serialization.JsonPropertyNameAttribute");

        // If the attribute is present, return the value of its constructor (the JSON property name)
        if (jsonPropertyNameAttribute != null && jsonPropertyNameAttribute.ConstructorArguments.Length > 0)
        {
            return jsonPropertyNameAttribute.ConstructorArguments[0].Value?.ToString() ?? property.Name;
        }

        // If the attribute is not present, return the default property name
        return property.Name;
    }

    private static string ToCamelCase(string name)
    {
        if (string.IsNullOrEmpty(name) || char.IsLower(name[0]))
            return name;
        
        return char.ToLowerInvariant(name[0]) + name.Substring(1);
    }

    private static string GetDefaultValue(string typeName, bool isNullable)
    {
        var cleanTypeName = typeName.Replace("global::", "").Replace("?", "");
        
        if (isNullable)
            return "default";
        
        return cleanTypeName switch
        {
            "System.Boolean" or "bool" => "false",
            "System.String" or "string" => "string.Empty",
            "System.Int32" or "int" => "0",
            "System.Int64" or "long" => "0L",
            "System.Int16" or "short" => "(short)0",
            "System.UInt32" or "uint" => "0u",
            "System.UInt64" or "ulong" => "0ul",
            "System.UInt16" or "ushort" => "(ushort)0",
            "System.Single" or "float" => "0f",
            "System.Double" or "double" => "0d",
            "System.Decimal" or "decimal" => "0m",
            _ => "default"
        };
    }
}